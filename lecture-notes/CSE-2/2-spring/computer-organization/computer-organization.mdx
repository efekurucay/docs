---
title: Computer Organization
description: CSE 206 Computer Organization
icon: computer
---
## --TÃœRKÃ‡E--

## 1. Temel Kavramlar ve Bilgisayar Evrimi 

### 1.1 Bilgisayar Mimarisi - Organizasyonu
#### 1.1.1 Bilgisayar Mimarisi
Bilgisayar mimarisi, bir programcÄ± tarafÄ±ndan gÃ¶rÃ¼lebilen bir sistemin Ã¶zelliklerini ifade eder. BaÅŸka bir deyiÅŸle, bir programÄ±n mantÄ±ksal olarak yÃ¼rÃ¼tÃ¼lmesi Ã¼zerinde doÄŸrudan etkisi olan niteliklerdir. 
Ã–rnek nitelikleri : 
- Komut Seti: Ä°ÅŸlemcinin gerÃ§ekleÅŸtirebileceÄŸi bÃ¼tÃ¼n komutlar.
- Veri tiplerini temsil etmek iÃ§in kullanÄ±lan bit sayÄ±sÄ±: SayÄ±lar ve karakterler iÃ§in kaÃ§ bit kullanÄ±ldÄ±ÄŸÄ±.
- GiriÅŸ/Ã‡Ä±kÄ±ÅŸ (I/O) MekanizmalarÄ±: BilgisayarÄ±n dÄ±ÅŸ dÃ¼nyayla nasÄ±l iletiÅŸim kurduÄŸu.
- BelleÄŸe adresleme teknikleri: Verilere bellekte nasÄ±l eriÅŸildiÄŸi. 
Ã–zetle, bilgisayar mimarisi, programcÄ±nÄ±n yazdÄ±ÄŸÄ± programÄ±n nasÄ±l davranacaÄŸÄ±nÄ± ve hangi kaynaklara eriÅŸebileceÄŸini belirleyen Ã¼st dÃ¼zey bir bakÄ±ÅŸ aÃ§Ä±sÄ±dÄ±r
#### 1.1.2 Bilgisayar Organizasyonu
Bilgisayar organizasyonu ise, mimari Ã¶zellikleri gerÃ§ekleÅŸtiren operasyonel birimleri ve bunlarÄ±n birbirleri ile olan baÄŸlantÄ±larÄ±nÄ± ifade eder. Bu, programcÄ±ya ÅŸeffaf olan donanÄ±m detaylarÄ±nÄ± iÃ§erir.
Mimari tarafÄ±ndan belirlenen iÅŸlevselliÄŸi somutlaÅŸtÄ±rmak iÃ§in kullanÄ±lan fiziksel bileÅŸenleri ve nasÄ±l yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ±nÄ± ele alÄ±r. 

Ã–rnek nitelikleri: 
- **Kontrol sinyalleri:** Ä°ÅŸlemci iÃ§indeki ve arasÄ±ndaki veri akÄ±ÅŸÄ±nÄ± ve operasyonlarÄ± yÃ¶neten sinyaller.
- **Bilgisayar ve Ã§evre birimleri arasÄ±ndaki arayÃ¼zler**: GiriÅŸ Ã§Ä±kÄ±ÅŸ modÃ¼llerinin sisteme nasÄ±l baÄŸlandÄ±ÄŸÄ±.
- **KullanÄ±lan bellek teknolojisi**: RAM tÃ¼rÃ¼, Ã¶nbellek yapÄ±sÄ± gibi **donanÄ±msal** detaylar
- **Dahili iÅŸlemci veri yollarÄ±**: Ä°ÅŸlemci iÃ§indeki farklÄ± birimler arasÄ±ndaki iletiÅŸim yollarÄ±.
Ã–rneÄŸin, bir bilgisayarÄ±n mimarisi 32-bitlik bir veri yolu geniÅŸliÄŸi tanÄ±mlayabilir. Ancak organizasyonu, bu 32 veri yolunun fiziksel olarak nasÄ±l uygulandÄ±ÄŸÄ±nÄ±, hangi yongalar arasÄ±ndaki baÄŸlantÄ±larÄ± saÄŸladÄ±ÄŸÄ±nÄ± ve veri transferlerini kontrol etmek iÃ§in hangi sinyallerin kullanÄ±ldÄ±ÄŸÄ±nÄ± belirler. 

BaÅŸka bir Ã¶rnek olarak, komut setinde bir "**toplama**" komutu bulunmasÄ± **mimari** bir Ã¶zelliktir. Bu toplama iÅŸleminin ALU (Aritmetik MantÄ±k Birimi) iÃ§inde nasÄ±l gerÃ§ekleÅŸtirildiÄŸi ve hangi kontrol sinyallerinin aktive edildiÄŸi ise organizasyonel bir detaydÄ±r.

SonuÃ§ olarak, **bilgisayar organizasyonu**, tanÄ±mlanan mimari Ã¶zelliklerin donanÄ±msal olarak nasÄ±l hayata geÃ§irildiÄŸinin ayrÄ±ntÄ±lÄ± bir planÄ±nÄ± sunar. Hem bilgisayar mimarisi hem de organizasyonu, bir bilgisayar sisteminin iÅŸlevselliÄŸi ve performansÄ± Ã¼zerinde kritik bir rol oynar.

#### 1.1.3 IBM System / 370 Mimarisi
1970 yÄ±lÄ±nda IBM tarafÄ±ndan tanÄ±tÄ±lan bir bilgisayar mimarisidir. Bu mimari, Ã¶nemli bir yenilik olarak, birkaÃ§ **farklÄ± modeli** iÃ§ermekteydi. Bu sayede, baÅŸlangÄ±Ã§ta daha uygun fiyatlÄ± ve yavaÅŸ bir model satÄ±n alan bir kullanÄ±cÄ±, ihtiyaÃ§larÄ± arttÄ±kÃ§a daha pahalÄ± ve hÄ±zlÄ± bir modele geÃ§iÅŸ yapabiliyor, ancak mevcut yazÄ±lÄ±mlarÄ±nÄ± deÄŸiÅŸtirmek zorunda kalmÄ±yordu. 

IBM, zaman iÃ§inde teknoloji geliÅŸtikÃ§e yeni ve geliÅŸtirilmiÅŸ modeller sunmuÅŸ olsa da, bu yeni modeller aynÄ± temel mimariyi korumuÅŸtur. 
ÅaÅŸÄ±rtÄ±cÄ± bir ÅŸekilde, System/370 mimarisi, zaman iÃ§inde yapÄ±lan bazÄ± geliÅŸtirmelerle birlikte, gÃ¼nÃ¼mÃ¼zde hala IBM'in ana bilgisayar Ã¼rÃ¼n serisinin temel mimarisi olarak varlÄ±ÄŸÄ±nÄ± sÃ¼rdÃ¼rmektedir.  Bu durum, bir mimarin yÄ±llarca var olabileceÄŸi ve teknolojik deÄŸiÅŸikliklerle birlikte organizasyonunun deÄŸiÅŸebileceÄŸi Ã¶nemli bir Ã¶rnektir.

System/370, aynÄ± zamanda "aile kavramÄ±" olarak bilinen bir yaklaÅŸÄ±ma da Ã¶ncÃ¼lÃ¼k etmiÅŸtir. Bu kavram, kullanÄ±cÄ±lara aynÄ± mimariyi sunan, ancak farklÄ± fiyat ve performans Ã¶zelliklerine sahip bir dizi bilgisayar modelini iÃ§erir. Fiyat ve performans farklÄ±lÄ±klarÄ±, aynÄ± mimarinin farklÄ± donanÄ±msal uygulamalarÄ±ndan kaynaklanÄ±r. 

Ã–zetle, IBM System/370 mimarisi, gerekli esnekliÄŸi sunan, yazÄ±lÄ±m yatÄ±rÄ±mÄ±nÄ± koruyan ve teknolojik geliÅŸmelere ayak uydurabilen baÅŸarÄ±lÄ± bir bilgisayar mimarisi Ã¶rneÄŸidir. FarklÄ± modelleri, yÃ¼kseltme kolaylÄ±ÄŸÄ± ve uzun Ã¶mÃ¼rlÃ¼lÃ¼ÄŸÃ¼ sayesinde, uzun yÄ±llar boyunca biliÅŸim dÃ¼nyasÄ±nda Ã¶nemli bir yere sahip olmuÅŸtur.

### 1.2 YapÄ± ve iÅŸlev 

#### 1.2.1 HiyerarÅŸik DÃ¼zen
KarmaÅŸÄ±k sistemler hiyerarÅŸik bir yapÄ±ya sahiptir. Bu, sistemin, her biri kendi iÃ§inde de hiyerarÅŸik bir yapÄ±ya sahip olabilen birbirleriyle iliÅŸkili alt sistemlerden oluÅŸtuÄŸu anlamÄ±na gelir.

HiyerarÅŸik yapÄ± karmaÅŸÄ±k sistemlerin anlaÅŸÄ±lmasÄ± ve tasarlanmasÄ± sÃ¼recini bÃ¼yÃ¼k Ã¶lÃ§Ã¼de kolaylaÅŸtÄ±rÄ±r.

**TasarÄ±mcÄ± aÃ§Ä±sÄ±ndan** dÃ¼ÅŸÃ¼nÃ¼rsek sistemin yalnÄ±zca **belirli bir seviyesi** ile ilgilenme ihtiyacÄ± duyar. Bu da karmaÅŸÄ±k genel yapÄ±da kaybolmadan ilgili seviyeye ve bileÅŸenlere odaklanmasÄ±nÄ± saÄŸlar. 

**AÃ§Ä±klama aÃ§Ä±sÄ±ndan** ise karmaÅŸÄ±k bir sistemi tanÄ±mlarken, yukarÄ±dan aÅŸaÄŸÄ±ya (top-down) bir yaklaÅŸÄ±m benimsemek genellikle en aÃ§Ä±k ve etkili yÃ¶ntemdir. Bu yaklaÅŸÄ±mda, Ã¶ncelikle sistemin ana bileÅŸenleri ve iÅŸlevleri tanÄ±mlanÄ±r, ardÄ±ndan her bir bileÅŸen daha alt seviyedeki alt bileÅŸenlere ayrÄ±ÅŸtÄ±rÄ±larak yapÄ± ve iÅŸlevleri detaylandÄ±rÄ±lÄ±r. Bu sayede, karmaÅŸÄ±k bir sistem adÄ±m adÄ±m ve anlaÅŸÄ±lÄ±r bir ÅŸekilde aÃ§Ä±klanabilir.
#### 1.2.2 YapÄ± (Structure): 
Bir seviyedeki bileÅŸenlerin birbirleriyle nasÄ±l iliÅŸkili olduÄŸunu ifade eder. Bu, bileÅŸenlerin dÃ¼zenlenme biÃ§imi, aralarÄ±ndaki baÄŸlantÄ±lar ve iletiÅŸim yollarÄ± gibi fiziksel veya mantÄ±ksal dÃ¼zenlemeleri kapsar. 
Ã–rneÄŸin, bir bilgisayarÄ±n yapÄ±sÄ± denildiÄŸinde, CPU, ana bellek, giriÅŸ/Ã§Ä±kÄ±ÅŸ (I/O) birimleri ve bu birimleri birbirine baÄŸlayan sistem ara baÄŸlantÄ±sÄ± (genellikle bir veri yolu - bus) akla gelir.
- CPU'nun kendi iÃ§indeki yapÄ± ise kontrol birimi, ALU ve kaydedicilerden oluÅŸur.
	- Kaydedicilerin ALU ile olan baÄŸlantÄ±larÄ± da CPU'nun iÃ§ yapÄ±sÄ±nÄ±n bir parÃ§asÄ±dÄ±r.

Bir bilgisayarÄ±n dÃ¶rt temel yapÄ±sal bileÅŸeni vardÄ±r:

##### Merkezi Ä°ÅŸlem Birimi (CPU): 
BilgisayarÄ±n operasyonunu kontrol eder ve veri iÅŸleme iÅŸlevlerini yerine getirir.
- **Ä°Ã§ yapÄ±sÄ±** kontrol birimi, aritmetik ve mantÄ±k birimi (ALU), kaydediciler ve CPU iÃ§ baÄŸlantÄ±sÄ±ndan oluÅŸur
- **Ä°ÅŸlevi,** programdaki talimatlarÄ± sÄ±rayla alÄ±p (fetch), Ã§Ã¶zÃ¼p (decode) ve Ã§alÄ±ÅŸtÄ±rmaktÄ±r. (execute)
##### Ana Bellek (Main Memory):
Verileri saklar.
- **YapÄ±sÄ±**, adreslenebilir bellek hÃ¼crelerinden oluÅŸur.
- **Ä°ÅŸlevi**, CPU tarafÄ±ndan ihtiyaÃ§ duyulan talimatlarÄ± ve verileri geÃ§ici olarak depolamaktÄ±r.
- **Bellek hiyerarÅŸisi** kavramÄ± da, daha hÄ±zlÄ± ve kÃ¼Ã§Ã¼k olan Ã¶nbelleklerden (cache) daha yavaÅŸ ve bÃ¼yÃ¼k olan ana belleÄŸe kadar farklÄ± seviyelerdeki bellek yapÄ±larÄ±nÄ± iÃ§erir.
##### GiriÅŸ/Ã‡Ä±kÄ±ÅŸ (I/O):
Bilgisayar ile dÄ±ÅŸ ortam arasÄ±ndaki veri hareketini saÄŸlar.
- YapÄ±sÄ±, Ã§evre birimleriyle (klavye, ekran, disk vb.) ve sistem ara baÄŸlantÄ±sÄ±yla (veri yolu) etkileÅŸim kuran I/O modÃ¼llerinden oluÅŸur.
- Ä°ÅŸlevi, dÄ±ÅŸ dÃ¼nyadan veri almak ve iÅŸlenmiÅŸ veriyi dÄ±ÅŸ dÃ¼nyaya gÃ¶ndermektir.
##### Sistem Ara BaÄŸlantÄ±sÄ± (System Interconnection):
CPU, ana bellek ve I/O birimleri arasÄ±ndaki iletiÅŸimi saÄŸlayan mekanizmadÄ±r. En yaygÄ±n Ã¶rneklerinden biri sistem veri yoludur (system bus). 
- Veri yolu, veri, adres ve kontrol hatlarÄ±ndan oluÅŸur ve bu bileÅŸenler arasÄ±nda bilgi alÄ±ÅŸveriÅŸini mÃ¼mkÃ¼n kÄ±lar.
- Daha geliÅŸmiÅŸ sistemlerde ise noktadan noktaya (point-to-point) baÄŸlantÄ±lar veya PCI Express (PCIe) gibi daha karmaÅŸÄ±k ara baÄŸlantÄ± yapÄ±larÄ± kullanÄ±labilir.
- Ã‡ok iÅŸlemcili sistemlerde, iÅŸlemciler arasÄ±ndaki iletiÅŸimi saÄŸlamak iÃ§in farklÄ± baÄŸlantÄ± aÄŸlarÄ± (interconnection networks) kullanÄ±labilir.

#### 1.2.3 Ä°ÅŸlev (Function): 
YapÄ± iÃ§indeki bireysel bileÅŸenlerin operasyonunu, yani nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± ve sistemin genel amacÄ±na nasÄ±l katkÄ±da bulunduÄŸunu ifade eder. Bir bileÅŸenin iÅŸlevi, genel sistemin bir parÃ§asÄ± olarak gerÃ§ekleÅŸtirdiÄŸi Ã¶zel gÃ¶revdir.
Ã–rneÄŸin; 
- CPU'nun temel iÅŸlevi programdaki talimatlarÄ± yÃ¼rÃ¼tmektir.
- Ana belleÄŸin iÅŸlevi veri depolamaktÄ±r.
- ALU'nun iÅŸlevi aritmetik ve mantÄ±ksal iÅŸlemleri gerÃ§ekleÅŸtirmektir.
- Kontrol biriminin iÅŸlevi ise CPU'nun ve dolayÄ±sÄ±yla bilgisayarÄ±n operasyonunu kontrol etmektir.

##### Veri Ä°ÅŸleme: 
Ä°ÅŸlemci veriler Ã¼zerinde aritmetik veya mantÄ±ksal iÅŸlemler gerÃ§ekleÅŸtirebilir.

##### Veri Depolama: 
Bellek, verileri kÄ±sa veya uzun sÃ¼reli olarak saklayabilir.
##### Veri Hareketi: 
G/Ã‡ birimleri, bilgisayar ile Ã§evresel aygÄ±tlar arasÄ±nda veri transferi saÄŸlar.

##### Kontrol: 
Kontrol Ã¼nitesi, diÄŸer tÃ¼m bileÅŸenlerin Ã§alÄ±ÅŸmasÄ±nÄ± yÃ¶netir ve koordine eder. Bir komut, yÃ¼rÃ¼tme sÄ±rasÄ±nÄ±n deÄŸiÅŸtirilmesini belirtebilir.


#### 1.2.4 Ã‡ok Ã‡ekirdekli Bilgisayar YapÄ±sÄ±
##### Merkezi iÅŸlem birimi (CPU)
- TalimatlarÄ± getiren ve yÃ¼rÃ¼ten bilgisayar bÃ¶lÃ¼mÃ¼
- Bir ALU, bir kontrol Ã¼nitesi ve kayÄ±tlardan oluÅŸur
- Tek bir iÅŸlem birimine sahip bir sistemde iÅŸlemci olarak adlandÄ±rÄ±lÄ±r
##### Ã‡ekirdek

Bir iÅŸlemci Ã§ipi Ã¼zerindeki bireysel bir iÅŸlem birimidir. Tek CPU'lu bir sistemde iÅŸlevsellik aÃ§Ä±sÄ±ndan bir CPU'ya eÅŸdeÄŸer olabilir. Bir Ã§ekirdeÄŸin genel iÅŸlevsel elemanlarÄ± ÅŸunlardÄ±r:
- Komut MantÄ±ÄŸÄ±: KomutlarÄ± getirme ve her bir komutu, komutun operasyonunu ve herhangi bir operandÄ±n bellek konumunu belirlemek iÃ§in Ã§Ã¶zme gÃ¶revlerini iÃ§erir.
- Aritmetik ve MantÄ±k Birimi (ALU): Bir komut tarafÄ±ndan belirtilen operasyonu gerÃ§ekleÅŸtirir.
- YÃ¼kle/Depola MantÄ±ÄŸÄ±: Verilerin Ã¶nbellek aracÄ±lÄ±ÄŸÄ±yla ana belleÄŸe ve ana bellekten transferini yÃ¶netir.
Ã–zel iÅŸlem birimlerine Ã§ekirdekler de denir
SimÃ¼latÃ¶r, bir komut setini baÅŸka bir sete eÅŸleyen bir araÃ§tÄ±r.
##### Ä°ÅŸlemci
- Bir veya daha fazla Ã§ekirdek iÃ§eren fiziksel bir silikon parÃ§asÄ±
- TalimatlarÄ± yorumlayan ve yÃ¼rÃ¼ten bilgisayar bileÅŸenidir
- Birden fazla Ã§ekirdek iÃ§eriyorsa Ã§ok Ã§ekirdekli iÅŸlemci olarak adlandÄ±rÄ±lÄ±r

#### 1.2.5 Ã–nbellek (Cache) 
- Ä°ÅŸlemci ve ana bellek arasÄ±nda yer alan Ã§ok katmanlÄ± bir bellek sistemidir. 
- Ana bellekten daha kÃ¼Ã§Ã¼k ve daha hÄ±zlÄ±dÄ±r.
- Temel amacÄ±, ana bellekteki verilere eriÅŸim sÃ¼resini kÄ±saltarak bellek eriÅŸimini hÄ±zlandÄ±rmaktÄ±r. Bu hÄ±zlanma, yakÄ±n gelecekte kullanÄ±lma olasÄ±lÄ±ÄŸÄ± yÃ¼ksek olan verilerin ana bellekten Ã¶nbelleÄŸe yerleÅŸtirilmesiyle saÄŸlanÄ±r.
##### Ã‡oklu Seviyeli Ã–nbellek: 
PerformansÄ± daha da artÄ±rmak iÃ§in Ã§oklu seviyeli cache kullanÄ±lÄ±r. Genellikle Ã¼Ã§ seviye bulunur:

- **Seviye 1 (L1) cache:** Ã‡ekirdeÄŸe en yakÄ±n olan ve en hÄ±zlÄ± ancak en kÃ¼Ã§Ã¼k cache seviyesidir. L1 cache genellikle komut (I-cache) ve veri (D-cache) olmak Ã¼zere ikiye ayrÄ±lÄ±r.
- **Seviye 2 (L2) cache:** L1'den daha yavaÅŸ ancak daha bÃ¼yÃ¼ktÃ¼r ve genellikle her Ã§ekirdeÄŸe Ã¶zel olabilir veya Ã§ekirdekler arasÄ±nda paylaÅŸÄ±labilir.
- Seviye 3 (L3) cache: L2'den daha yavaÅŸ ve daha bÃ¼yÃ¼k olan bu seviye genellikle birden fazla Ã§ekirdek tarafÄ±ndan paylaÅŸÄ±lÄ±r. BazÄ± sistemlerde L4 gibi daha fazla seviye de bulunabilir.
Cache seviyeleri iÅŸlemciden uzaklaÅŸtÄ±kÃ§a **boyutlarÄ± artar** ancak **eriÅŸim hÄ±zlarÄ± dÃ¼ÅŸer**. 

Ä°ÅŸlemci Ã¶ncelikle en hÄ±zlÄ± ve en yakÄ±n olan L1 cache'inde aradÄ±ÄŸÄ± veriyi bulmaya Ã§alÄ±ÅŸÄ±r. Veri burada bulunamazsa (cache miss), sÄ±rasÄ±yla L2 ve L3 cache'lerinde aranÄ±r. Veri hiÃ§bir cache seviyesinde bulunamazsa, ana belleÄŸe eriÅŸilir. 

L1 --> L2 --> L3 --> ANA BELLEK

##### Ã–nbelleÄŸin FaydalarÄ±:
- **Bellek gecikmesini azaltÄ±r:** SÄ±k kullanÄ±lan verilere daha hÄ±zlÄ± eriÅŸim saÄŸlayarak iÅŸlemcinin bekleme sÃ¼resini azaltÄ±r.
-  **Sistem performansÄ±nÄ± artÄ±rÄ±r:** Daha hÄ±zlÄ± veri eriÅŸimi, programlarÄ±n daha hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar ve genel sistem performansÄ±nÄ± yÃ¼kseltir.
- **Veri yolu trafiÄŸini azaltÄ±r:** Cache hit durumunda ana belleÄŸe eriÅŸim gerekmediÄŸinden, sistem veri yolu Ã¼zerindeki yÃ¼k azalÄ±r.
##### TasarÄ±m ElemanlarÄ±:

- Cache Adresleri (Cache Addresses): Sanal (logical) veya fiziksel adresler kullanÄ±labilir.
- Cache Boyutu (Cache Size): Performans ve maliyet arasÄ±nda bir denge sÃ¶z konusudur. Ä°ÅŸlemci Ã§iplerinde cache iÃ§in ayrÄ±lan alan zamanla artmÄ±ÅŸtÄ±r.
- EÅŸleme Fonksiyonu (Mapping Function): Ana bellek bloklarÄ±nÄ±n cache hatlarÄ±na nasÄ±l eÅŸleneceÄŸini belirler. DoÄŸrudan eÅŸleme (direct), tam iliÅŸkisel (associative) ve kÃ¼me iliÅŸkisel (set-associative) gibi teknikler bulunur
- Yer DeÄŸiÅŸtirme AlgoritmasÄ± (Replacement Algorithm): Cache dolu olduÄŸunda hangi bloÄŸun Ã§Ä±karÄ±lacaÄŸÄ±nÄ± belirler. En az kullanÄ±lan (LRU) gibi algoritmalar vardÄ±r.
- Yazma PolitikasÄ± (Write Policy): Cache'teki bir veri gÃ¼ncellendiÄŸinde ana belleÄŸin ne zaman gÃ¼ncelleneceÄŸini belirler. Yazma yoluyla (write-through) ve geri yazma (write-back) gibi politikalar mevcuttur.
- Hat Boyutu (Line Size): Bir cache bloÄŸunun (veya hattÄ±nÄ±n) kaÃ§ kelime veya bayttan oluÅŸtuÄŸunu ifade eder
##### Ã‡ok Ã‡ekirdekli Sistemlerde Cache:
Ã‡ok Ã§ekirdekli iÅŸlemcilerde cache organizasyonu daha karmaÅŸÄ±k hale gelir. Her Ã§ekirdeÄŸin kendi Ã¶zel L1 ve L2 cache'leri olabileceÄŸi gibi, bazÄ± seviyeler (Ã¶zellikle L3) tÃ¼m Ã§ekirdekler tarafÄ±ndan paylaÅŸÄ±labilir. Cache tutarlÄ±lÄ±ÄŸÄ± (cache coherence), birden fazla Ã§ekirdek aynÄ± bellek konumundaki veriyi cache'lediÄŸinde, tÃ¼m cache'lerdeki verinin tutarlÄ± kalmasÄ±nÄ± saÄŸlama sorunudur.


### 1.3 BilgisayarlarÄ±n Tarihi

#### 1.3.1 Birinci Nesil - Vakum TÃ¼pleri  

Bilgisayar tarihinin Birinci Nesli, dijital mantÄ±k elemanlarÄ± ve bellek iÃ§in vakum tÃ¼plerinin kullanÄ±ldÄ±ÄŸÄ± dÃ¶nemi ifade eder. Bu dÃ¶nemin Ã¶nemli bir Ã¶rneÄŸi, IAS bilgisayarÄ±dÄ±r.
- IAS bilgisayarÄ±nÄ±n temel tasarÄ±m yaklaÅŸÄ±mÄ±, genellikle matematikÃ§i John von Neumann'a atfedilen **depolanmÄ±ÅŸ program** kavramÄ±ydÄ±.
- Bu fikrin ilk yayÄ±nlanmasÄ± 1945 yÄ±lÄ±nda yeni bir bilgisayar olan EDVAC (Elektronik AyrÄ±k DeÄŸiÅŸkenli Bilgisayar) iÃ§in **von Neumann** tarafÄ±ndan yapÄ±lan bir Ã¶neriyle gerÃ§ekleÅŸti.
- IAS bilgisayarÄ±nÄ±n tasarÄ±mÄ±, Princeton Ä°leri AraÅŸtÄ±rmalar EnstitÃ¼sÃ¼'nde 1946 yÄ±lÄ±nda baÅŸladÄ± ve 1952 yÄ±lÄ±nda tamamlandÄ±.
- **IAS bilgisayarÄ±**, sonraki tÃ¼m **genel amaÃ§lÄ± bilgisayarlarÄ±n** prototipi oldu.

IAS bilgisayarÄ±nÄ±n yapÄ±sÄ± (Åekil 1.6) aÅŸaÄŸÄ±daki temel bileÅŸenleri iÃ§eriyordu:
- Merkezi Ä°ÅŸlem Birimi (CPU): BilgisayarÄ±n iÅŸlemlerini kontrol eden ve veri iÅŸleme fonksiyonlarÄ±nÄ± yerine getiren birimdir. IAS bilgisayarÄ±nda bu birim, Aritmetik-lojik birimi (CA) ve Program kontrol birimini (CC) iÃ§eriyordu.
- Ana Bellek (Main Memory): Hem verileri hem de komutlarÄ± depolayan alandÄ±r. IAS bilgisayarÄ±nÄ±n belleÄŸi 40 bitlik 1000 depolama konumundan (kelime) oluÅŸuyordu.
- GiriÅŸ/Ã‡Ä±kÄ±ÅŸ (I/O) EkipmanlarÄ±: Kontrol birimi tarafÄ±ndan iÅŸletilen, bilgisayarÄ±n dÄ±ÅŸ dÃ¼nya ile iletiÅŸimini saÄŸlayan aygÄ±tlardÄ±r.


![[Pasted image 20250411004607.png]]

IAS bilgisayarÄ±nda Ã§eÅŸitli kayÄ±tÃ§Ä±lar (registers) bulunuyordu. Bunlardan bazÄ±larÄ± ÅŸunlardÄ±r:

- AC (AkÃ¼mÃ¼latÃ¶r KayÄ±tÃ§Ä±sÄ±)

- MQ (Ã‡arpÄ±m-BÃ¶lÃ¼m KayÄ±tÃ§Ä±sÄ±)

- MBR (Bellek Tampon KayÄ±tÃ§Ä±sÄ±): BelleÄŸe depolanacak veya bellekten alÄ±nacak kelimeyi iÃ§erir
- IBR (Komut Tampon KayÄ±tÃ§Ä±sÄ±): Bellekteki bir kelimeden geÃ§ici olarak saÄŸ taraftaki komutu tutmak iÃ§in kullanÄ±lÄ±rdÄ±.
- Modern sistemlerde bunun yerine genellikle pipeline kullanÄ±lÄ±r. IAS bilgisayarÄ±nÄ±n her kelimesinde iki komut (sol ve saÄŸ) bulunuyordu.
- PC (Program SayacÄ±): Bir sonraki alÄ±nacak komut Ã§iftinin adresini iÃ§erir.
- MAR (Bellek Adres KayÄ±tÃ§Ä±sÄ±): Bir okuma veya yazma iÅŸlemi iÃ§in bellekteki adresi belirtir.
- IR (Komut KayÄ±tÃ§Ä±sÄ±): Åu anda yÃ¼rÃ¼tÃ¼len 8-bitlik iÅŸlem kodu (opcode) komutunu iÃ§erir.

IAS bilgisayarÄ± ayrÄ±ca ikili (binary) veriler Ã¼zerinde iÅŸlem yapabilen bir aritmetik ve mantÄ±k birimine (ALU) sahipti. Kontrol birimi ise bellekteki komutlarÄ± yorumlayÄ±p yÃ¼rÃ¼tÃ¼lmelerini saÄŸlÄ±yordu. GiriÅŸ/Ã§Ä±kÄ±ÅŸ (I/O) ekipmanlarÄ± da kontrol birimi tarafÄ±ndan yÃ¶netiliyordu.

![[Pasted image 20250411025133.png]]
 
Åekil 1.7, IAS bilgisayarÄ±nÄ±n bellek biÃ§imlerini gÃ¶stermektedir. Bellekte hem veri hem de komutlar saklanÄ±yordu. SayÄ±lar, bir iÅŸaret biti ve 39 bÃ¼yÃ¼klÃ¼k biti ile temsil ediliyordu. Komut kelimesi ise 20 bitlik sol ve saÄŸ komut olmak Ã¼zere ikiye ayrÄ±lÄ±yordu. Her bir 20 bitlik komut, 8 bitlik bir iÅŸlem kodu (opcode) ve 12 bitlik bir adres iÃ§eriyordu. Bu 12 bitlik adres, 4096 (2^12) farklÄ± bellek konumunu adresleyebiliyordu.


##### DepolanmÄ±ÅŸ Program kavramÄ±  
DepolanmÄ±ÅŸ program kavramÄ±, hem verilerin hem de komutlarÄ±n aynÄ± ana bellekte saklanmasÄ± fikrine dayanÄ±r. Bu sayede bilgisayar, programlarÄ± art arda (sÄ±ralÄ± bir ÅŸekilde) Ã§alÄ±ÅŸtÄ±rabilir. ProgramÄ±n yÃ¼rÃ¼tÃ¼lmesi genel olarak getir (fetch), Ã§Ã¶z (decode) ve Ã§alÄ±ÅŸtÄ±r (execute) dÃ¶ngÃ¼sÃ¼ ÅŸeklinde gerÃ§ekleÅŸir. 

#### 1.3.2 Ä°kinci Nesil - TransistÃ¶rler

- Daha **KÃ¼Ã§Ã¼k**
- Daha **Ucuz**
- Daha az Ä±sÄ± yayar.
- Silikondan yapÄ±lmÄ±ÅŸ katÄ± hal cihazÄ±dÄ±r
- 1947'de Bell Labs'ta icat edildi.
- Tam transistÃ¶rlÃ¼ bilgisayarlar ticari olarak 1950'lerin sonuna kadar mevcut deÄŸildi.


| Generation | Approximate Dates | Technology                      | Typical Speed (operations per second) |
|------------|-------------------|---------------------------------|---------------------------------------|
| 1          | 1946â€“1957         | Vacuum tube                     | 40,000                                |
| 2          | 1957â€“1964         | Transistor                      | 200,000                               |
| 3          | 1965â€“1971         | Small and medium scale integration | 1,000,000                             |
| 4          | 1972â€“1977         | Large scale integration         | 10,000,000                            |
| 5          | 1978â€“1991         | Very large scale integration    | 100,000,000                           |
| 6          | 1991-             | Ultra large scale integration   | >1,000,000,000                        |

##### Ä°kinci Nesil Bilgisayarlar


**TanÄ±tÄ±lan Yenilikler:**

* Daha karmaÅŸÄ±k aritmetik ve mantÄ±k birimleri (ALU) ve kontrol birimleri.
* YÃ¼ksek seviyeli programlama dillerinin kullanÄ±mÄ±.
* AÅŸaÄŸÄ±daki yetenekleri saÄŸlayan sistem yazÄ±lÄ±mlarÄ±nÄ±n sunulmasÄ±:
    * ProgramlarÄ± yÃ¼kleme
    * Verileri Ã§evresel birimlere taÅŸÄ±ma
    * KÃ¼tÃ¼phanelerin yaygÄ±n hesaplamalarÄ± yapmasÄ±


![[Pasted image 20250411030523.png]]


#### 1.3.3 ÃœÃ§Ã¼ncÃ¼ Nesil - Entegre Devre
Bilgisayar tarihinin ÃœÃ§Ã¼ncÃ¼ Nesli, entegre devrelerin icadÄ±yla tanÄ±mlanÄ±r. 1958 yÄ±lÄ±nda icat edilen entegre devreler, elektronik alanÄ±nda bir devrim baÅŸlatmÄ±ÅŸtÄ±r. 

Bu nesilden Ã¶nce, elektronik ekipmanlar bÃ¼yÃ¼k Ã¶lÃ§Ã¼de ayrÄ±k bileÅŸenlerden oluÅŸuyordu. Tek baÅŸÄ±na, kendi kendine yeten bir transistÃ¶r olan bu ayrÄ±k bileÅŸenler ayrÄ± ayrÄ± Ã¼retiliyor, kendi kutularÄ±nda paketleniyor ve masonit benzeri devre kartlarÄ±na lehimleniyor veya kablolanÄ±yordu. Bu Ã¼retim sÃ¼reci hem pahalÄ± hem de zahmetliydi. Ä°kinci nesil bilgisayarlarda kullanÄ±lan transistÃ¶r sayÄ±sÄ± yÃ¼z binlere ulaÅŸÄ±nca, daha gÃ¼Ã§lÃ¼ makinelerin Ã¼retimi giderek zorlaÅŸmaya baÅŸlamÄ±ÅŸtÄ±.

Entegre devre, bu sorunlara bir Ã§Ã¶zÃ¼m getirerek mikroelektronik Ã§aÄŸÄ±nÄ± baÅŸlatmÄ±ÅŸtÄ±r. Temel bilgisayar elemanlarÄ± olan mantÄ±k kapÄ±larÄ± (gates) ve bellek hÃ¼creleri (memory cells), transistÃ¶rler ve kapasitÃ¶rler gibi basit dijital elektronik bileÅŸenlerden inÅŸa edilir. Entegre devreler, transistÃ¶rler, direnÃ§ler ve iletkenler gibi bileÅŸenlerin silikon gibi bir yarÄ± iletkenden Ã¼retilebilmesi gerÃ§eÄŸini kullanÄ±r. AyrÄ± ayrÄ± silikon parÃ§alarÄ±ndan yapÄ±lan ayrÄ±k bileÅŸenleri aynÄ± devreye monte etmek yerine, bÃ¼tÃ¼n bir devre minik bir silikon parÃ§asÄ± Ã¼zerine fabrikasyonla yerleÅŸtirilir. Tek bir silikon gofret **(wafer)** Ã¼zerinde aynÄ± anda Ã§ok sayÄ±da transistÃ¶r Ã¼retilebilir. Daha da Ã¶nemlisi, bu transistÃ¶rler iÅŸlemci metalizasyonu ile baÄŸlanarak devreleri oluÅŸturabilirler. 

Åekil 1.10'da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi, bir bilgisayar temelde veri depolama, iÅŸleme, taÅŸÄ±ma ve kontrol fonksiyonlarÄ±nÄ± yerine getiren kapÄ±lar ve bellek hÃ¼creleri olmak Ã¼zere iki temel bileÅŸen tÃ¼rÃ¼ne ihtiyaÃ§ duyar.

![[Pasted image 20250411031534.png]]

- Veri depolama, bellek hÃ¼creleri tarafÄ±ndan saÄŸlanÄ±r.
- Veri iÅŸleme, kapÄ±lar tarafÄ±ndan saÄŸlanÄ±r.
- Veri hareketi, bileÅŸenler arasÄ±ndaki yollar aracÄ±lÄ±ÄŸÄ±yla, bellekten belleÄŸe ve bellekten kapÄ±lara doÄŸru gerÃ§ekleÅŸir.
- Kontrol, bileÅŸenler arasÄ±ndaki yollar aracÄ±lÄ±ÄŸÄ±yla kontrol sinyalleri taÅŸÄ±narak saÄŸlanÄ±r.


Åekil 1.11, entegre devrelerdeki temel kavramlarÄ± gÃ¶stermektedir. Ä°nce bir silikon gofret, her biri birkaÃ§ milimetre kare olan kÃ¼Ã§Ã¼k alanlarÄ±n bir matrisine bÃ¶lÃ¼nÃ¼r. Her alanda aynÄ± devre deseni oluÅŸturulur ve gofret Ã§ipler halinde kesilir. Her bir Ã§ip, birÃ§ok kapÄ± ve/veya bellek hÃ¼cresi ile birlikte bir dizi giriÅŸ ve Ã§Ä±kÄ±ÅŸ baÄŸlantÄ± noktasÄ± iÃ§erir. Bu Ã§ip daha sonra, onu koruyan ve Ã§ipin Ã¶tesindeki cihazlara baÄŸlanmak iÃ§in pinler saÄŸlayan bir pakete yerleÅŸtirilir.

![[Pasted image 20250411031629.png]]

Entegre devrelerin ayrÄ±k bileÅŸenlere gÃ¶re birÃ§ok avantajÄ± vardÄ±r:

- Maliyet dÃ¼ÅŸÃ¼klÃ¼ÄŸÃ¼: Silikon Ã¼zerindeki bileÅŸenlerin toplu Ã¼retimi maliyeti dÃ¼ÅŸÃ¼rÃ¼r.
- KÃ¼Ã§Ã¼k boyut: Ã‡ok sayÄ±da bileÅŸen kÃ¼Ã§Ã¼k bir alana sÄ±ÄŸdÄ±rÄ±labilir.
- YÃ¼ksek hÄ±z: MantÄ±k ve bellek elemanlarÄ± birbirine daha yakÄ±n yerleÅŸtirildiÄŸinden, elektrik yolu kÄ±salÄ±r ve Ã§alÄ±ÅŸma hÄ±zÄ± artar.
- Daha az gÃ¼Ã§ tÃ¼ketimi.
- Daha yÃ¼ksek gÃ¼venilirlik: Entegre devre Ã¼zerindeki baÄŸlantÄ±lar, lehim baÄŸlantÄ±larÄ±ndan daha gÃ¼venilirdir ve Ã§ip baÅŸÄ±na daha fazla devre olduÄŸundan, Ã§ipler arasÄ± baÄŸlantÄ± sayÄ±sÄ± azalÄ±r.


ÃœÃ§Ã¼ncÃ¼ neslin en Ã¶nemli iki Ã¼yesi IBM System/360 ve DEC PDP-8 olmuÅŸtur.

DEC PDP-8, nispeten dÃ¼ÅŸÃ¼k maliyeti ve kÃ¼Ã§Ã¼k boyutu sayesinde diÄŸer Ã¼reticilerin PDP-8'i kendi sistemlerine entegre ederek yeniden satmalarÄ±nÄ± saÄŸlamÄ±ÅŸtÄ±r. Bu Ã¼reticilere orijinal ekipman Ã¼reticileri (OEM) denmiÅŸ ve OEM pazarÄ± bilgisayar pazarÄ±nÄ±n Ã¶nemli bir bÃ¶lÃ¼mÃ¼ haline gelmiÅŸtir. IBM'in 700/7000 ve 360 sistemlerinde kullanÄ±lan merkezi anahtarlamalÄ± mimarinin (Åekil 1.9) aksine, PDP-8'in sonraki modelleri, mikrobilgisayarlar iÃ§in neredeyse evrensel hale gelen bir yapÄ± kullanmÄ±ÅŸtÄ±r: bus yapÄ±sÄ± (Åekil 1.13). PDP-8 bus'Ä±, Omnibus, kontrol, adres ve veri sinyallerini taÅŸÄ±mak iÃ§in kullanÄ±lan 96 ayrÄ± sinyal yolundan oluÅŸuyordu.




Åekil 1.12, entegre devrelerdeki transistÃ¶r sayÄ±sÄ±ndaki bÃ¼yÃ¼meyi gÃ¶stermektedir. Bu bÃ¼yÃ¼me, daha Ã¶nceki konuÅŸmamÄ±zda da bahsettiÄŸimiz gibi, Intel'in kurucu ortaÄŸÄ± Gordon Moore tarafÄ±ndan 1965'te Ã¶ne sÃ¼rÃ¼len Moore YasasÄ± ile yakÄ±ndan iliÅŸkilidir. Moore YasasÄ±, bir yonga Ã¼zerine yerleÅŸtirilebilecek transistÃ¶r sayÄ±sÄ±nÄ±n yaklaÅŸÄ±k olarak her iki yÄ±lda bir ikiye katlanacaÄŸÄ±nÄ± Ã¶ngÃ¶rÃ¼yordu. 

![[Pasted image 20250411032737.png]]

#### 1.3.4  Sonraki nesiller - YarÄ±iletken Bellek MikroiÅŸlemcileri

Bilgisayar tarihinin Ã¼Ã§Ã¼ncÃ¼ neslinden sonraki dÃ¶nemler, entegre devre teknolojisindeki ilerlemelerle tanÄ±mlanmÄ±ÅŸtÄ±r.

| Generation | Approximate Dates | Technology                      | Typical Speed (operations per second) |
|------------|-------------------|---------------------------------|---------------------------------------|
| 1          | 1946â€“1957         | Vacuum tube                     | 40,000                                |
| 2          | 1957â€“1964         | Transistor                      | 200,000                               |
| 3          | 1965â€“1971         | Small and medium scale integration | 1,000,000                             |
| 4          | 1972â€“1977         | Large scale integration         | 10,000,000                            |
| 5          | 1978â€“1991         | Very large scale integration    | 100,000,000                           |
| 6          | 1991-             | Ultra large scale integration   | >1,000,000,000                        |
Sonraki nesilleri entegre devrelerdeki bileÅŸen sayÄ±sÄ±na gÃ¶re sÄ±nÄ±flandÄ±rmaktadÄ±r.

- LSI (Large Scale Integration): Tek bir entegre devre Ã§ipinde 1.000'den fazla bileÅŸenin yerleÅŸtirilebildiÄŸi dÃ¶nem. 
	- Bu dÃ¶nem kabaca 1972-1977 yÄ±llarÄ±nÄ± kapsar.
- VLSI (Very Large Scale Integration): Ã‡ip baÅŸÄ±na 10.000'den fazla bileÅŸenin sÄ±ÄŸdÄ±rÄ±labildiÄŸi dÃ¶nem.
	-  Bu dÃ¶nem yaklaÅŸÄ±k olarak 1978-1991 yÄ±llarÄ±nÄ± kapsar.
- ULSI (Ultra Large Scale Integration): GÃ¼nÃ¼mÃ¼zde kullanÄ±lan ve bir milyardan fazla bileÅŸeni tek bir Ã§ip Ã¼zerinde barÄ±ndÄ±rabilen teknolojidir.
	-  Bu dÃ¶nem 1991 yÄ±lÄ±ndan sonra baÅŸlamÄ±ÅŸtÄ±r.
Bu dÃ¶nemlerdeki en Ã¶nemli geliÅŸmelerden ikisi yarÄ± iletken bellekler ve mikroiÅŸlemciler olmuÅŸtur.

##### 1.3.4.1 YarÄ± Ä°letken Bellekler:
- 1970 yÄ±lÄ±nda Fairchild, nispeten bÃ¼yÃ¼k kapasiteli ilk yarÄ± iletken belleÄŸi Ã¼retmiÅŸtir. Bu Ã§ip, tek bir manyetik Ã§ekirdek boyutlarÄ±ndaydÄ± ve 256 bit veri saklayabiliyordu. AyrÄ±ca non-destrÃ¼ktif (okuma sÄ±rasÄ±nda veri silinmiyordu) ve manyetik Ã§ekirdekten Ã§ok daha hÄ±zlÄ±ydÄ±.
- 1974 yÄ±lÄ±nda yarÄ± iletken belleÄŸin bit baÅŸÄ±na maliyeti, manyetik Ã§ekirdek belleÄŸin maliyetinin altÄ±na dÃ¼ÅŸmÃ¼ÅŸtÃ¼r. Bu olay, yarÄ± iletken belleÄŸin ana bellek teknolojisi olarak yaygÄ±nlaÅŸmasÄ±nÄ±n Ã¶nÃ¼nÃ¼ aÃ§mÄ±ÅŸtÄ±r.
- 1970'ten bu yana yarÄ± iletken bellek teknolojisi 13 nesil geÃ§irmiÅŸtir. Her yeni nesil, bir Ã¶nceki neslin dÃ¶rt katÄ± depolama yoÄŸunluÄŸu sunarken, bit baÅŸÄ±na maliyet dÃ¼ÅŸmÃ¼ÅŸ ve eriÅŸim sÃ¼resi kÄ±salmÄ±ÅŸtÄ±r. Ã–rneÄŸin, 1k, 4k, 16k, 64k, 256k, 1M, 4M, 16M, 64M, 256M, 1G, 4G ve gÃ¼nÃ¼mÃ¼zde 8 Gb'lÄ±k Ã§ipler Ã¼retilmiÅŸtir. 
- Bellek teknolojisindeki bu hÄ±zlÄ± geliÅŸmeler, bilgisayarlarÄ±n yapÄ±sÄ±nÄ± Ã¶nemli Ã¶lÃ§Ã¼de deÄŸiÅŸtirmiÅŸ ve daha kÃ¼Ã§Ã¼k, daha hÄ±zlÄ± ve daha bÃ¼yÃ¼k bellek kapasitelerine sahip makinelerin ortaya Ã§Ä±kmasÄ±nÄ± saÄŸlamÄ±ÅŸtÄ±r
##### 1.3.4.2 MikroiÅŸlemciler:
- Ä°ÅŸlemci Ã§iplerindeki eleman yoÄŸunluÄŸu sÃ¼rekli olarak artmÄ±ÅŸtÄ±r. Bu sayede tek bir bilgisayar iÅŸlemcisini oluÅŸturmak iÃ§in gereken Ã§ip sayÄ±sÄ± azalmÄ±ÅŸtÄ±r.
- 1971 yÄ±lÄ±nda Intel, bir CPU'nun tÃ¼m bileÅŸenlerini **tek bir Ã§ip** Ã¼zerinde barÄ±ndÄ±ran ilk Ã§ip olan **4004**'Ã¼ geliÅŸtirmiÅŸtir. Bu, mikroiÅŸlemcinin doÄŸuÅŸu olarak kabul edilir. 
	- 4004, 4-bitlik sayÄ±larÄ± toplayabiliyor ve yalnÄ±zca tekrarlÄ± toplama yoluyla Ã§arpma iÅŸlemi yapabiliyordu.
- 1972 yÄ±lÄ±nda Intel, ilk 8-bit mikroiÅŸlemci olan 8008'i geliÅŸtirmiÅŸtir.
- 1974 yÄ±lÄ±nda Intel, ilk genel amaÃ§lÄ± mikroiÅŸlemci olan 8080'i piyasaya sÃ¼rmÃ¼ÅŸtÃ¼r. 8080, 8-bitlik bir mikroiÅŸlemci olmasÄ±na raÄŸmen, 4004 ve 8008'e gÃ¶re daha hÄ±zlÄ±ydÄ±, daha zengin bir komut kÃ¼mesine sahipti ve daha geniÅŸ bir adresleme yeteneÄŸi sunuyordu.
	- 8080, ilk kiÅŸisel bilgisayar olan Altair'de kullanÄ±lmÄ±ÅŸtÄ±r.
- AynÄ± dÃ¶nemde 16-bit mikroiÅŸlemciler de geliÅŸtirilmeye baÅŸlanmÄ±ÅŸ, 1970'lerin sonunda ise gÃ¼Ã§lÃ¼ ve genel amaÃ§lÄ± 16-bit mikroiÅŸlemciler ortaya Ã§Ä±kmÄ±ÅŸtÄ±r. Bunlardan biri 8086 idi. 8088, 8086'nÄ±n bir tÃ¼reviydi ve IBM'in ilk kiÅŸisel bilgisayarÄ±nda kullanÄ±larak Intel'in baÅŸarÄ±sÄ±nÄ± saÄŸlamlaÅŸtÄ±rmÄ±ÅŸtÄ±r. 8086, x86 mimarisinin ilk gÃ¶rÃ¼nÃ¼mÃ¼dÃ¼r.
- Daha sonra 32-bit mikroiÅŸlemciler geliÅŸtirilmiÅŸtir. Intel'in ilk 32-bit iÅŸlemcisi olan 80386, 1985 yÄ±lÄ±nda piyasaya sÃ¼rÃ¼lmÃ¼ÅŸtÃ¼r ve Ã§oklu gÃ¶rev (multitasking) desteÄŸi sunan ilk Intel iÅŸlemcisidir.
- Intel'in mikroiÅŸlemci evrimi, Moore YasasÄ± ile yakÄ±ndan iliÅŸkilidir. Gordon Moore, 1965 yÄ±lÄ±nda tek bir Ã§ip Ã¼zerine yerleÅŸtirilebilecek transistÃ¶r sayÄ±sÄ±nÄ±n her yÄ±l ikiye katlandÄ±ÄŸÄ±nÄ± gÃ¶zlemlemiÅŸ ve bu hÄ±zÄ±n devam edeceÄŸini Ã¶ngÃ¶rmÃ¼ÅŸtÃ¼r.
- Daha sonra bu hÄ±z her 18 ayda bir ikiye katlanma ÅŸeklinde revize edilmiÅŸ ve bu oran bÃ¼yÃ¼k Ã¶lÃ§Ã¼de korunmuÅŸtur.
- Moore YasasÄ±'nÄ±n sonuÃ§larÄ± arasÄ±nda bilgisayar mantÄ±k ve bellek devrelerinin maliyetinin dÃ¼ÅŸmesi, Ã§alÄ±ÅŸma hÄ±zÄ±nÄ±n artmasÄ±, bilgisayarlarÄ±n kÃ¼Ã§Ã¼lmesi, gÃ¼Ã§ tÃ¼ketiminin azalmasÄ± ve Ã§ip arasÄ± baÄŸlantÄ± sayÄ±sÄ±nÄ±n azalmasÄ± yer alÄ±r.
- Bu geliÅŸmeler, bilgisayar teknolojisinin sonraki nesillerinde Ã§ok daha karmaÅŸÄ±k ve gÃ¼Ã§lÃ¼ sistemlerin ortaya Ã§Ä±kmasÄ±na olanak tanÄ±mÄ±ÅŸtÄ±r.

##### 1.3.4.3 Intel MikroiÅŸlemcilerin Evrimi

###### (a) 1970s Processors

|                     | 4004     | 8008     | 8080     | 8086                 | 8088           |
|---------------------|----------|----------|----------|----------------------|----------------|
| Introduced          | 1971     | 1972     | 1974     | 1978                 | 1979           |
| Clock speeds        | 108 kHz  | 108 kHz  | 2 MHz    | 5 MHz, 8 MHz, 10 MHz | 5 MHz, 8 MHz   |
| Bus width           | 4 bits   | 8 bits   | 8 bits   | 16 bits              | 8 bits         |
| Number of transistors| 2,300    | 3,500    | 6,000    | 29,000               | 29,000         |
| Feature size (Âµm)   | 10       | 8        | 6        | 3                    | 6              |
| Addressable memory  | 640 Bytes| 16 KB    | 64 KB    | 1 MB                 | 1 MB           |


###### (b) 1980s Processors

|                     | 80286          | 386TM DX         | 386TM SX         | 486TM DX CPU     |
|---------------------|----------------|------------------|------------------|------------------|
| Introduced          | 1982           | 1985             | 1988             | 1989             |
| Clock speeds        | 6 MHz - 12.5 MHz| 16 MHz - 33 MHz  | 16 MHz - 33 MHz  | 25 MHz - 50 MHz  |
| Bus width           | 16 bits        | 32 bits          | 16 bits          | 32 bits          |
| Number of transistors| 134,000        | 275,000          | 275,000          | 1.2 million      |
| Feature size (Âµm)   | 1.5            | 1                | 1                | 0.8 - 1          |
| Addressable memory  | 16 MB          | 4 GB             | 16 MB            | 4 GB             |
| Virtual memory      | 1 GB           | 64 TB            | 64 TB            | 64 TB            |
| Cache               | â€”              | â€”                | â€”                | 8 kB             |

###### (c) 1990s Processors


|                       | 486TM SX        | Pentium          | Pentium Pro           | Pentium II        |
| --------------------- | --------------- | ---------------- | --------------------- | ----------------- |
| Introduced            | 1991            | 1993             | 1995                  | 1997              |
| Clock speeds          | 16 MHz - 33 MHz | 60 MHz - 166 MHz | 150 MHz - 200 MHz     | 200 MHz - 300 MHz |
| Bus width             | 32 bits         | 32 bits          | 64 bits               | 64 bits           |
| Number of transistors | 1.185 million   | 3.1 million      | 5.5 million           | 7.5 million       |
| Feature size (Âµm)     | 1               | 0.8              | 0.6                   | 0.35              |
| Addressable memory    | 4 GB            | 4 GB             | 64 GB                 | 64 GB             |
| Virtual memory        | 64 TB           | 64 TB            | 64 TB                 | 64 TB             |
| Cache                 | 8 kB            | 8 kB             | 512 kB L1 and 1 MB L2 | 512 kB L2         |

###### (d) Recent Processors

|                       | Pentium III   | Pentium 4     | Core 2 Duo     | Core i7 EE 4960X     |
| --------------------- | ------------- | ------------- | -------------- | -------------------- |
| Introduced            | 1999          | 2000          | 2006           | 2013                 |
| Clock speeds          | 450 - 660 MHz | 1.3 - 1.8 GHz | 1.06 - 1.2 GHz | 4 GHz                |
| Bus width             | 64 bits       | 64 bits       | 64 bits        | 64 bits              |
| Number of transistors | 9.5 million   | 42 million    | 167 million    | 1.86 billion         |
| Feature size (nm)     | 250           | 180           | 65             | 22                   |
| Addressable memory    | 64 GB         | 64 GB         | 64 GB          | 64 GB                |
| Virtual memory        | 64 TB         | 64 TB         | 64 TB          | 64 TB                |
| Cache                 | 512 kB L2     | 256 kB L2     | 2 MB L2        | 1.5 MB L2 / 15 MB L3 |
| Number of cores       | 1             | 1             | 2              | 6                    |
|                       |               |               |                |                      |

###### Intel x86 Mimarisinin Evrimi

Intel x86 ve ARM mimarileri, gÃ¼nÃ¼mÃ¼zdeki iki temel iÅŸlemci ailesini temsil etmektedir. Mevcut x86 iÅŸlemcileri, karmaÅŸÄ±k komut seti bilgisayarlarÄ± (CISC) Ã¼zerine on yÄ±llarca sÃ¼ren bir tasarÄ±m Ã§alÄ±ÅŸmasÄ±nÄ±n sonucudur. Buna karÅŸÄ±lÄ±k, indirgenmiÅŸ komut seti bilgisayarÄ± (RISC), iÅŸlemci tasarÄ±mÄ±nda alternatif bir yaklaÅŸÄ±mÄ± temsil eder. ARM mimarisi, Ã§ok Ã§eÅŸitli gÃ¶mÃ¼lÃ¼ sistemlerde kullanÄ±lmakta olup, piyasadaki en gÃ¼Ã§lÃ¼ ve en iyi tasarlanmÄ±ÅŸ RISC tabanlÄ± sistemlerden biridir.

.
.

| Ä°ÅŸlemci     | Ã–ne Ã‡Ä±kan Ã–zellikler                                                                                                                                                                                                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 4004        | 1971'de , bir CPU'nun tÃ¼m bileÅŸenlerini tek bir Ã§ip Ã¼zerinde barÄ±ndÄ±ran ilk Ã§ipti ve mikroiÅŸlemcinin doÄŸuÅŸunu iÅŸaret etti. Ancak, sadece 4-bitlik sayÄ±larla iÅŸlem yapabiliyor ve Ã§arpma iÅŸlemini tekrarlÄ± toplama ile gerÃ§ekleÅŸtirebiliyordu.                                                              |
| 8008        | 1972'de, ilk 8-bit mikroiÅŸlemci olarak ortaya Ã§Ä±ktÄ±.                                                                                                                                                                                                                                                       |
| 8080        | - DÃ¼nyanÄ±n ilk genel amaÃ§lÄ± mikroiÅŸlemcisi  <br> - 8-bit makine, belleÄŸe 8-bit veri yolu  <br> - Ä°lk kiÅŸisel bilgisayarda (Altair) kullanÄ±ldÄ±<br> - 8-bitlik olmasÄ±na raÄŸmen, daha hÄ±zlÄ±ydÄ±, daha zengin bir komut setine ve daha geniÅŸ bir adresleme yeteneÄŸine sahipti.                                  |
| 8086        | - 1978'de Intel 8086, daha gÃ¼Ã§lÃ¼ bir 16-bit makineydi<br> - TalimatlarÄ± yÃ¼rÃ¼tÃ¼lmeden Ã¶nce Ã¶nbelleÄŸe alan bir komut kuyruÄŸuna sahiptir.  <br> - x86 mimarisinin ilk ortaya Ã§Ä±kÄ±ÅŸÄ±   <br> - 8088 bu iÅŸlemcinin bir varyantÄ±ydÄ± ve IBM'in ilk kiÅŸisel bilgisayarÄ±nda kullanÄ±ldÄ± (Intel'in baÅŸarÄ±sÄ±nÄ± saÄŸladÄ±) |
| 80286       | - 8086â€™nÄ±n geniÅŸletilmiÅŸ versiyonu, sadece 1 MB yerine 16 MB belleÄŸe adresleme yapÄ±lmasÄ±nÄ± saÄŸladÄ±                                                                                                                                                                                                         |
| 80386       | - Intel'in ilk 32-bit iÅŸlemcisi  <br> - Ã‡oklu gÃ¶rev desteÄŸi sunan ilk Intel iÅŸlemcisi                                                                                                                                                                                                                      |
| 80486       | - Daha geliÅŸmiÅŸ ve gÃ¼Ã§lÃ¼ Ã¶nbellek teknolojisinin ve geliÅŸmiÅŸ komut ardÄ±ÅŸÄ±klÄ±ÄŸÄ±nÄ±n (instruction pipelining) kullanÄ±mÄ±  <br> - Dahili matematik iÅŸlem birimi (coprocessor) iÃ§eriyordu                                                                                                                        |
| Pentium     | - Birden fazla komutun aynÄ± anda yÃ¼rÃ¼tÃ¼lmesine olanak tanÄ±yan superscalar (Ã¼stdizisel) tekniklerin kullanÄ±mÄ±nÄ± tanÄ±ttÄ±                                                                                                                                                                                     |
| Pentium Pro | - Superscalar yapÄ±ya geÃ§iÅŸ devam etti; kayÄ±t yeniden adlandÄ±rma, dallanma tahmini, veri akÄ±ÅŸÄ± analizi ve varsayÄ±msal yÃ¼rÃ¼tme gibi teknikler yoÄŸun ÅŸekilde kullanÄ±ldÄ±                                                                                                                                       |
| Pentium II  | - Video, ses ve grafik verilerini verimli bir ÅŸekilde iÅŸlemek iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸ Intel MMX teknolojisini entegre etti                                                                                                                                                                            |
| Pentium III | - Ek kayan nokta komutlarÄ± iÃ§erir  <br> - SIMD AkÄ±ÅŸ UzantÄ±larÄ± (SSE) iÃ§erir                                                                                                                                                                                                                                |
| Pentium 4   | - Multimedya iÃ§in ek kayan nokta komutlarÄ± ve diÄŸer geliÅŸtirmeler iÃ§erir                                                                                                                                                                                                                                   |
| Core        | - Ä°lk Intel x86 mikro Ã§ekirdeÄŸi                                                                                                                                                                                                                                                                            |
| Core 2      | - Core mimarisini 64 bit'e geniÅŸletir  <br> - Core 2 Quad tek bir Ã§ip Ã¼zerinde dÃ¶rt Ã§ekirdek saÄŸlar  <br> - Daha yeni Core sÃ¼rÃ¼mleri Ã§ip baÅŸÄ±na 10'a kadar Ã§ekirdek iÃ§erebilir  <br> - Mimaride Ã¶nemli bir ekleme: GeliÅŸmiÅŸ VektÃ¶r UzantÄ±larÄ± (AVX) komut seti                                             |

###### CISC ve RISC YaklaÅŸÄ±mlarÄ±

Kaynaklar, **x86** mimarisinin bir **CISC (Complex Instruction Set Computer - KarmaÅŸÄ±k Komut Seti BilgisayarÄ±)** mimarisi olduÄŸunu belirtirken, **ARM** mimarisinin ise **RISC (Reduced Instruction Set Computer - Ä°ndirgenmiÅŸ Komut Seti BilgisayarÄ±)** tasarÄ±m prensiplerinden evrimleÅŸtiÄŸini vurgulamaktadÄ±r.

- **CISC mimarileri**, genellikle Ã§ok sayÄ±da karmaÅŸÄ±k komuta sahiptir ve derleyicileri basitleÅŸtirmeyi, performansÄ± artÄ±rmayÄ± hedefler.  
  Ancak bu karmaÅŸÄ±klÄ±k, iÅŸlemci tasarÄ±mÄ±nÄ± zorlaÅŸtÄ±rabilir.  
  **x86'nÄ±n** karmaÅŸÄ±k komut seti; geriye dÃ¶nÃ¼k uyumluluk ihtiyacÄ± ve derleyici geliÅŸtiricilerine mÃ¼mkÃ¼n olan en fazla desteÄŸi saÄŸlama isteÄŸinden kaynaklanmaktadÄ±r.

- **RISC mimarileri** ise daha az sayÄ±da, basit komutlara odaklanÄ±r ve komut iÅŸlem hattÄ±nÄ± (**pipeline**) optimize etmeyi amaÃ§lar.  
  **ARM mimarisi**, enerji verimliliÄŸi ve kÃ¼Ã§Ã¼k Ã§ip boyutu ile bilinir; bu da onu **gÃ¶mÃ¼lÃ¼ sistemlerde** yaygÄ±n kÄ±lar.

RISC ve CISC YakÄ±nsamasÄ±

Son yÄ±llarda, **RISC** ve **CISC** yaklaÅŸÄ±mlarÄ± arasÄ±nda bir **yakÄ±nsama** olduÄŸu gÃ¶rÃ¼lmektedir:

- **RISC tasarÄ±mlarÄ±**, bazÄ± **CISC** Ã¶zelliklerinden faydalanabilir.
- **CISC tasarÄ±mlarÄ±** ise, performansÄ± artÄ±rmak iÃ§in **RISC prensiplerini** benimseyebilir.  
  Ã–rneÄŸin, modern **x86 iÅŸlemcileri**, **superscalar** yapÄ±lar ve **iÅŸlem hattÄ±** gibi RISC temelli teknikleri kullanmaktadÄ±r.

 SonuÃ§ olarak, 

- **Intel x86 mimarisi**, yÄ±llar iÃ§inde sÃ¼rekli olarak geliÅŸmiÅŸ ve karmaÅŸÄ±klaÅŸmÄ±ÅŸtÄ±r.
  - Geriye dÃ¶nÃ¼k uyumluluk ve geniÅŸ uygulama desteÄŸi ihtiyacÄ±, **CISC** yapÄ±sÄ±nÄ±n korunmasÄ±na neden olmuÅŸtur.
- Buna karÅŸÄ±lÄ±k, **ARM mimarisi**, **RISC** prensipleriyle yola Ã§Ä±karak Ã¶zellikle gÃ¶mÃ¼lÃ¼ sistemlerde bÃ¼yÃ¼k bir baÅŸarÄ±ya ulaÅŸmÄ±ÅŸtÄ±r.

Her iki mimari de:
- Performans
- Enerji verimliliÄŸi

gibi faktÃ¶rleri dengeleyerek evrimleÅŸmeye devam etmektedir.


##### GÃ¶mÃ¼lÃ¼ Sistemler

GÃ¶mÃ¼lÃ¼ sistemler, bir Ã¼rÃ¼n iÃ§inde elektronik ve yazÄ±lÄ±mÄ±n kullanÄ±lmasÄ± anlamÄ±na gelir. Elektrik gÃ¼cÃ¼ kullanan birÃ§ok cihazda gÃ¶mÃ¼lÃ¼ bir biliÅŸim sistemi bulunmaktadÄ±r. YakÄ±n gelecekte neredeyse tÃ¼m bu cihazlarda gÃ¶mÃ¼lÃ¼ sistemlerin olmasÄ± beklenmektedir.

###### GerÃ§ek ZamanlÄ± KÄ±sÄ±tlamalar

GÃ¶mÃ¼lÃ¼ sistemler genellikle Ã§evrelerine sÄ±kÄ± sÄ±kÄ±ya baÄŸlÄ±dÄ±r:

- Ã‡evreyle etkileÅŸim gereksinimi gerÃ§ek zamanlÄ± kÄ±sÄ±tlamalar doÄŸurur.
- Zamanlama, hareket hÄ±zÄ±, Ã¶lÃ§Ã¼m hassasiyeti ve iÅŸlem sÃ¼resi gibi kriterler Ã¶nemlidir.
- AynÄ± anda birden fazla aktivite yÃ¶netilmesi gerektiÄŸinde bu kÄ±sÄ±tlamalar daha da karmaÅŸÄ±klaÅŸÄ±r.

###### GÃ¶mÃ¼lÃ¼ Sistemlerin KullanÄ±m AlanlarÄ±

GÃ¶mÃ¼lÃ¼ sistemlere sahip cihazlarÄ±n tÃ¼rleri neredeyse sayÄ±sÄ±zdÄ±r:

- Cep telefonlarÄ±, dijital/video kameralar, hesap makineleri
- Mikrodalga fÄ±rÄ±nlar, ev gÃ¼venlik sistemleri, Ã§amaÅŸÄ±r makineleri
- AydÄ±nlatma sistemleri, termostatlar, yazÄ±cÄ±lar
- Otomotiv sistemleri (ÅŸanzÄ±man kontrolÃ¼, hÄ±z sabitleyici, ABS, sÃ¼spansiyon)

###### Tipik GÃ¶mÃ¼lÃ¼ Sistem Organizasyonu

Åekil 1.14â€™te gÃ¶sterildiÄŸi gibi:

- **SensÃ¶rler ve aktÃ¼atÃ¶rler** ile Ã§evreyle etkileÅŸim
- **Ä°nsan arayÃ¼zÃ¼**: Basit LEDâ€™den karmaÅŸÄ±k robotik gÃ¶rÃ¼ÅŸ sistemlerine kadar Ã§eÅŸitlenebilir
- **TeÅŸhis portlarÄ±**
- **FPGA, ASIC** gibi Ã¶zel donanÄ±m kullanÄ±mÄ±
- **Uygulamaya Ã¶zel yazÄ±lÄ±m**
- **Enerji, kod boyutu, maliyet ve zaman aÃ§Ä±sÄ±ndan optimize edilmiÅŸtir**
![[Pasted image 20250411041104.png]]


###### Genel AmaÃ§lÄ± Bilgisayarlarla Benzerlikler

- **YÃ¼kseltilebilirlik**: YazÄ±lÄ±m gÃ¼ncellemeleri artÄ±k gÃ¶mÃ¼lÃ¼ sistemlerde de Ã¶nemlidir.
- **GÃ¶mÃ¼lÃ¼ platformlar**: AkÄ±llÄ± telefonlar ve akÄ±llÄ± TVâ€™ler bu platformlara Ã¶rnektir.

###### IoT ve Derinlemesine GÃ¶mÃ¼lÃ¼ Sistemler

**Nesnelerin Ä°nterneti (IoT)**, gÃ¶mÃ¼lÃ¼ sistemlerin yaygÄ±nlaÅŸmasÄ±nÄ± hÄ±zlandÄ±rmÄ±ÅŸtÄ±r:

- Cihazlar arasÄ±nda yeni iletiÅŸim biÃ§imleri geliÅŸtirilmektedir.
- IoT, **dÃ¼ÅŸÃ¼k bant geniÅŸliÄŸi**, **dÃ¼ÅŸÃ¼k tekrar oranÄ±**, **gÃ¶zlemlenmesi zor sistemler** ile karakterize edilir.
- **Mikrodenetleyiciler** kullanÄ±lÄ±r; genellikle programlandÄ±ktan sonra deÄŸiÅŸtirilemezler.
- Kablosuz baÄŸlantÄ± ve geniÅŸ alanlara daÄŸÄ±tÄ±lmÄ±ÅŸ sensÃ¶r aÄŸlarÄ± ile Ã§alÄ±ÅŸÄ±rlar.
- AÅŸÄ±rÄ± kaynak kÄ±sÄ±tlamalarÄ±na (bellek, zaman, gÃ¼Ã§) sahiptirler.

###### GÃ¶mÃ¼lÃ¼ Ä°ÅŸletim Sistemi YaklaÅŸÄ±mlarÄ±

1. **Genel iÅŸletim sistemlerinin uyarlanmasÄ±**  
   - Ã–rn: GÃ¶mÃ¼lÃ¼ Linux, Windows Embedded, macOS tÃ¼revleri
2. **SÄ±fÄ±rdan gÃ¶mÃ¼lÃ¼ OS geliÅŸtirme**  
   - Ã–rn: **TinyOS**, Ã¶zellikle kablosuz sensÃ¶r aÄŸlarÄ±nda kullanÄ±lÄ±r

###### YaygÄ±n Terimler

- **Uygulama Ä°ÅŸlemcileri**:  
  - Android, Linux, Chrome OS Ã§alÄ±ÅŸtÄ±rabilir; genel amaÃ§lÄ±dÄ±r.  
  - Ã–rn: AkÄ±llÄ± telefonlar

- **Ã–zel AmaÃ§lÄ± Ä°ÅŸlemciler**:  
  - Belirli gÃ¶revler iÃ§in optimize edilir.  
  - Boyut ve maliyet avantajÄ± saÄŸlar.

- **MikroiÅŸlemciler**:  
  - ALU, yazmaÃ§lar ve kontrol mantÄ±ÄŸÄ± iÃ§erir.  
  - ArtÄ±k Ã§ok Ã§ekirdekli ve bÃ¼yÃ¼k Ã¶nbellekli modeller vardÄ±r.

- **Mikrodenetleyiciler**:  
  - â€œÃ‡ip Ã¼zeri bilgisayarâ€  
  - Oyuncaklardan araÃ§lara kadar milyarlarca Ã¼rÃ¼n iÃ§inde bulunur.  
  - Tipik olarak MHz hÄ±zÄ±nda Ã§alÄ±ÅŸÄ±r, insanla doÄŸrudan etkileÅŸimi yoktur.  
  - GiriÅŸlere tepki vererek cihazlarÄ± kontrol ederler.  
  - 4-bitâ€™ten 32-bitâ€™e kadar farklÄ± mimarilerde bulunurlar.

###### Mikrodenetleyici YapÄ±sÄ±

- Ä°ÅŸlemci, RAM, ROM, I/O portlarÄ±, zamanlayÄ±cÄ±lar, ADC/DAC gibi bileÅŸenler tek Ã§ip Ã¼zerinde entegredir.
- Åekil 1.15 ve 1.16'da Ã¶rnek yapÄ±lar gÃ¶sterilmektedir.
![[Pasted image 20250411041127.png]]

![[Pasted image 20250411041138.png]]
###### ARM ve GÃ¶mÃ¼lÃ¼ Sistemler

- **ARM**, RISC tabanlÄ± mikroiÅŸlemci/mikrodenetleyici ailesidir.
- DÃ¼ÅŸÃ¼k gÃ¼Ã§ tÃ¼ketimi ve kÃ¼Ã§Ã¼k kalÄ±p boyutlarÄ± ile bilinir.
- ARM Holdings iÅŸlemci Ã¼retmez, tasarÄ±m lisansÄ± verir.
- **ARM lisanslarÄ±**:
  - Ä°ÅŸlemci Ã§ekirdeÄŸi lisansÄ±
  - Mimari lisansÄ±

 - ARM Ä°ÅŸlemci Aileleri

	- **Cortex-A**: Uygulama iÅŸlemcileri
	- **Cortex-R**: GerÃ§ek zamanlÄ± sistemler
	- **Cortex-M**: Mikrodenetleyici uygulamalarÄ±

	**Cortex-M**:
	- Harvard mimarisi kullanÄ±r (komut ve veri yollarÄ± ayrÄ±)
	- AynÄ± anda veri ve komut eriÅŸimi mÃ¼mkÃ¼ndÃ¼r â†’ paralel iÅŸlem artar

###### GÃ¶mÃ¼lÃ¼ Sistemlerde Bellek

- **NOR flash**: Kodun deÄŸiÅŸmediÄŸi kÃ¼Ã§Ã¼k uygulamalar iÃ§in uygundur (dahili bellek)
- **NAND flash**: Harici veri depolama (USB, SSD vb.)

###### Veri Yolu KullanÄ±mÄ±

- Mikrodenetleyicilerde veri yolu hÃ¢lÃ¢ yaygÄ±n bir baÄŸlantÄ± yÃ¶ntemidir.
- PaylaÅŸÄ±mlÄ± iletim ortamÄ± ile cihazlar arasÄ± iletiÅŸimi saÄŸlar.

#####  Bulut BiliÅŸiminin TanÄ±mÄ± ve Temel KavramlarÄ±

**NISTâ€™in tanÄ±mÄ±yla Bulut BiliÅŸim**:  
â€œÄ°htiyaÃ§ duyulduÄŸunda, her yerden eriÅŸilebilen, kullanÄ±ÅŸlÄ±, isteÄŸe baÄŸlÄ± aÄŸ eriÅŸimini, asgari yÃ¶netim Ã§abasÄ± veya servis saÄŸlayÄ±cÄ± etkileÅŸimi ile hÄ±zlÄ± bir ÅŸekilde tedarik edilebilen ve serbest bÄ±rakÄ±labilen, yapÄ±landÄ±rÄ±labilir biliÅŸim kaynaklarÄ±nÄ±n (Ã¶rneÄŸin, aÄŸlar, sunucular, depolama, uygulamalar ve hizmetler) paylaÅŸÄ±lan bir havuzuna saÄŸlayan bir modeldir.â€

######  Bulut BiliÅŸimin SaÄŸladÄ±ÄŸÄ± Temel Faydalar

- **Ã–lÃ§ek ekonomisi**: Kaynak paylaÅŸÄ±mÄ± ile maliyet avantajÄ±
- **Profesyonel aÄŸ yÃ¶netimi**
- **YÃ¼ksek dÃ¼zeyde gÃ¼venlik**
- **Ä°htiyaÃ§ kadar Ã¶deme**
- **KolaylÄ±k ve esneklik**

> â— GÃ¼venlik Ã¶nlemleri geliÅŸmiÅŸ olsa da, gÃ¼venlik ihlalleri yaÅŸanabilir.

###### Bulut AÄŸ Ä°letiÅŸimi (Cloud Networking)

- Bulut eriÅŸimini mÃ¼mkÃ¼n kÄ±lan aÄŸ yÃ¶netimi iÅŸlevlerini iÃ§erir.
- YÃ¼ksek performanslÄ± ve gÃ¼venilir aÄŸ baÄŸlantÄ±larÄ± saÄŸlar.
- GÃ¼venlik duvarlarÄ± ve gÃ¼venlik cihazlarÄ± ile eriÅŸim gÃ¼venliÄŸi desteklenir.
- Kurumsal veri merkezleri bulutla entegre edilebilir.

###### Bulut Depolama (Cloud Storage)

- Uzaktan barÄ±ndÄ±rÄ±lan veri depolama Ã§Ã¶zÃ¼mleri
- DonanÄ±m satÄ±n alma, bakÄ±m ve yÃ¶netim yÃ¼kÃ¼nden kurtarÄ±r
- Bireyler ve kÃ¼Ã§Ã¼k iÅŸletmeler iÃ§in Ã¶lÃ§eklenebilir Ã§Ã¶zÃ¼mler sunar

###### Bulut Hizmet Modelleri (Cloud Service Models)

1. **SaaS** (Software as a Service)
	- Uygulama dÃ¼zeyinde hizmet
	- Ã–rn: Gmail, Salesforce
	- YazÄ±lÄ±m kurulumu, bakÄ±mÄ± gerekmez

 2. **PaaS** (Platform as a Service)
	- YazÄ±lÄ±m geliÅŸtirme ortamÄ± saÄŸlar
	- Ã–rn: Google App Engine, Salesforce1
	- GeliÅŸtiriciler iÃ§in araÃ§ ve Ã§alÄ±ÅŸma zamanÄ± iÃ§erir

3. **IaaS** (Infrastructure as a Service)
	- Temel altyapÄ± hizmeti sunar
	- Ã–rn: Amazon EC2, Windows Azure
	- KullanÄ±cÄ±, iÅŸletim sistemi ve uygulamalarÄ± yÃ¶netebilir

> SaaS en az Ã¶zelleÅŸtirilebilir, IaaS en fazla Ã¶zelleÅŸtirilebilir yapÄ±dadÄ±r.

![[Pasted image 20250411041602.png]]


###### Bulut DaÄŸÄ±tÄ±m Modelleri (Cloud Deployment Models)

- Herkese AÃ§Ä±k Bulut (Public Cloud)
	- Genel kullanÄ±ma aÃ§Ä±k
	- Maliyet avantajÄ± yÃ¼ksek

- Ã–zel Bulut (Private Cloud)
	- Kuruma Ã¶zel altyapÄ±
	- GÃ¼venlik Ã¶nceliklidir

- Topluluk Bulutu (Community Cloud)
	- Benzer ihtiyaÃ§lara sahip kuruluÅŸlarÄ±n ortak altyapÄ±sÄ±

- Hibrit Bulut (Hybrid Cloud)
	- Ã–zel + AÃ§Ä±k/Topluluk bulutlarÄ±nÄ±n birleÅŸimi
	- TaÅŸÄ±nabilirlik ve entegrasyon sunar


###### Bulut BiliÅŸimin Temel Ã–zellikleri (NIST)

- **GeniÅŸ AÄŸ EriÅŸimi**: Mobil cihazlar dahil her yerden eriÅŸim
- **Kaynak Havuzu**: Ã‡oklu kullanÄ±cÄ±ya dinamik kaynak tahsisi
- **HÄ±zlÄ± Esneklik (Rapid Elasticity)**: Kaynaklar hÄ±zla Ã¶lÃ§eklenebilir
- **Ã–lÃ§Ã¼len Hizmet (Measured Service)**: Kaynak kullanÄ±mÄ± izlenir ve optimize edilir
- **Ä°steÄŸe BaÄŸlÄ± Self Servis**: KullanÄ±cÄ±lar hizmetleri kendi baÅŸlarÄ±na alabilir

###### Bulut BiliÅŸim Referans Mimarisi (NIST SP 500-292)

Ortak bir mimari Ã§erÃ§eve sunar. 5 ana aktÃ¶r tanÄ±mlanmÄ±ÅŸtÄ±r:

- Bulut TÃ¼keticisi (Cloud Consumer)
	- Hizmetleri kullanan kiÅŸi veya kuruluÅŸ

- Bulut SaÄŸlayÄ±cÄ±sÄ± (Cloud Provider)
	- Hizmeti sunan taraf

- Bulut DenetÃ§isi (Cloud Auditor)
	- GÃ¼venlik, performans ve uygunluk denetimini yapar

- Bulut AracÄ±sÄ± (Cloud Broker)
	- TÃ¼ketici ve saÄŸlayÄ±cÄ± arasÄ±ndaki iliÅŸkiyi yÃ¶netir
	- **GÃ¶revleri**: Hizmet aracÄ±lÄ±ÄŸÄ±, hizmet toplama, hizmet tahkimi

- Bulut TaÅŸÄ±yÄ±cÄ±sÄ± (Cloud Carrier)
	- TÃ¼ketici ile saÄŸlayÄ±cÄ± arasÄ±nda baÄŸlantÄ±yÄ± saÄŸlar

###### Genel DeÄŸerlendirme

Bulut biliÅŸim:
- **Modern biliÅŸim altyapÄ±sÄ±nÄ±n temel parÃ§alarÄ±ndan biridir.**
- **Esneklik**, **Ã¶lÃ§eklenebilirlik** ve **maliyet etkinliÄŸi** saÄŸlar.
- Ä°ÅŸletmeler ve bireyler iÃ§in bÃ¼yÃ¼k avantajlar sunar.





### 1.4 Ã–zet

#### ğŸ“Œ BÃ¶lÃ¼m BaÅŸlÄ±klarÄ±

- Organizasyon ve mimari
- YapÄ± ve iÅŸlev
- Bilgisayar tarihÃ§esi
- Bilgisayar nesilleri:
  - 1. Nesil: Vakum TÃ¼pleri
  - 2. Nesil: TransistÃ¶rler
  - 3. Nesil: Entegre Devreler
  - Sonraki nesiller (LSI, VLSI, ULSI)
- Intel x86 mimarisinin evrimi
- Bulut biliÅŸim (cloud computing)
  - Temel kavramlar
  - Hizmet modelleri
- GÃ¶mÃ¼lÃ¼ sistemler ve IoT
  - GÃ¶mÃ¼lÃ¼ iÅŸletim sistemleri
  - Ä°ÅŸlemci tÃ¼rleri: Uygulama / Ã–zel amaÃ§lÄ±, MikroiÅŸlemci / Mikrodenetleyici
- ARM mimarisi ve evrimi

---

#### ğŸ–¥ Bilgisayar Nesilleri

##### 1ï¸âƒ£ Birinci Nesil: **Vakum TÃ¼pleri**
- Dijital mantÄ±k elemanlarÄ± vakum tÃ¼pleriyle yapÄ±lÄ±rdÄ±.
- IAS bilgisayarÄ±, **von Neumann mimarisi** ile geliÅŸtirildi.
- ALU, bellek, kontrol birimi gibi temel bileÅŸenler tanÄ±mlandÄ±.

##### 2ï¸âƒ£ Ä°kinci Nesil: **TransistÃ¶rler**
- Daha kÃ¼Ã§Ã¼k, ucuz ve dÃ¼ÅŸÃ¼k Ä±sÄ± yayan bileÅŸenler
- Bilgisayar hÄ±zÄ±nda Ã¶nemli artÄ±ÅŸ

##### 3ï¸âƒ£ ÃœÃ§Ã¼ncÃ¼ Nesil: **Entegre Devreler (IC)**
- Tek bir Ã§ip Ã¼zerinde binlerce transistÃ¶r
- Daha kÃ¼Ã§Ã¼k, hÄ±zlÄ± ve gÃ¼venilir sistemler
- **PDP-8** gibi Ã¶rnek sistemler

##### ğŸ” Sonraki Nesiller:
- LSI, VLSI, ULSI teknolojileri ile milyarlarca transistÃ¶r
- Performans ve entegrasyon artÄ±ÅŸÄ±



#### ğŸ§  Intel x86 Mimarisi

- 1978: **8086** ile baÅŸladÄ±
- 2013: **Core i7 EE 4960X**â€™e kadar uzanan geliÅŸim
- CISC yapÄ±sÄ±ndadÄ±r (karmaÅŸÄ±k komut seti)
- Geriye dÃ¶nÃ¼k uyumluluk Ã¶nemlidir
- Saat hÄ±zlarÄ±, bellek ve transistÃ¶r sayÄ±sÄ± yÄ±llar iÃ§inde ciddi artÄ±ÅŸ gÃ¶stermiÅŸtir



#### â˜ï¸ Bulut BiliÅŸim (Cloud Computing)

##### TanÄ±m:
- Ä°htiyaÃ§ anÄ±nda eriÅŸilebilen paylaÅŸÄ±mlÄ± biliÅŸim kaynaklarÄ±

##### Temel Faydalar:
- Esneklik
- Ã–lÃ§eklenebilirlik
- Maliyet avantajÄ±
- Profesyonel gÃ¼venlik ve aÄŸ yÃ¶netimi

##### Hizmet Modelleri:
- **SaaS**: YazÄ±lÄ±m hizmeti (Ã¶rn. Gmail, Salesforce)
- **PaaS**: Platform hizmeti (Ã¶rn. Google App Engine)
- **IaaS**: AltyapÄ± hizmeti (Ã¶rn. Amazon EC2)

##### DaÄŸÄ±tÄ±m Modelleri:
- **Public Cloud**: Herkese aÃ§Ä±k
- **Private Cloud**: Kurum iÃ§i Ã¶zel
- **Community Cloud**: Ortak paylaÅŸÄ±m
- **Hybrid Cloud**: Hibrit yapÄ±


#### ğŸ”§ GÃ¶mÃ¼lÃ¼ Sistemler

- ÃœrÃ¼n iÃ§ine yerleÅŸtirilmiÅŸ Ã¶zel amaÃ§lÄ± bilgisayar sistemleri
- Milyarlarca cihazda kullanÄ±lÄ±r (mikrodalga, araba, TV vb.)
- Genellikle **mikrodenetleyici** iÃ§erir
- **GerÃ§ek zamanlÄ±** kÄ±sÄ±tlamalara tabidir

##### Ã–ne Ã‡Ä±kan Konular:
- **IoT** (Nesnelerin Ä°nterneti): GeniÅŸ cihaz baÄŸlantÄ±sÄ±
- **GÃ¶mÃ¼lÃ¼ Ä°ÅŸletim Sistemleri**: TinyOS, gÃ¶mÃ¼lÃ¼ Linux vb.
- **Uygulama vs. Ã–zel AmaÃ§lÄ± Ä°ÅŸlemciler**
- **MikroiÅŸlemci vs. Mikrodenetleyici**
- **GÃ¶mÃ¼lÃ¼ vs. Derinlemesine GÃ¶mÃ¼lÃ¼ Sistemler**


#### âš™ï¸ ARM Mimarisi

- RISC temelli, gÃ¶mÃ¼lÃ¼ sistemlerde yaygÄ±n
- **ARM Holdings** tarafÄ±ndan tasarlanÄ±r, lisansla Ã¼retilir
- Hafif, dÃ¼ÅŸÃ¼k enerji tÃ¼ketimli
- ÃœrÃ¼n aileleri:
  - **Cortex-A**: Uygulama iÅŸlemcileri
  - **Cortex-R**: GerÃ§ek zamanlÄ± uygulamalar
  - **Cortex-M**: Mikrodenetleyici Ã§Ã¶zÃ¼mleri

- **Harvard mimarisi** ile paralel veri ve komut aktarÄ±mÄ± yapÄ±labilir


#### ğŸ§¾ SonuÃ§

- BilgisayarlarÄ±n donanÄ±m/mimari geliÅŸimi nesillere ayrÄ±larak aÃ§Ä±klanmÄ±ÅŸtÄ±r.
- Intel x86 ve ARM gibi modern mimarilere detaylÄ± giriÅŸ yapÄ±lmÄ±ÅŸtÄ±r.
- Bulut biliÅŸim ve gÃ¶mÃ¼lÃ¼ sistemler Ã§aÄŸdaÅŸ teknolojilerin temel taÅŸlarÄ± olarak ele alÄ±nmÄ±ÅŸtÄ±r.

