---
title: Computer Organization
description: CSE 206 Computer Organization
icon: computer
---
## --TÜRKÇE--

## 1. Temel Kavramlar ve Bilgisayar Evrimi 

### 1.1 Bilgisayar Mimarisi - Organizasyonu
#### 1.1.1 Bilgisayar Mimarisi
Bilgisayar mimarisi, bir programcı tarafından görülebilen bir sistemin özelliklerini ifade eder. Başka bir deyişle, bir programın mantıksal olarak yürütülmesi üzerinde doğrudan etkisi olan niteliklerdir. 
Örnek nitelikleri : 
- Komut Seti: İşlemcinin gerçekleştirebileceği bütün komutlar.
- Veri tiplerini temsil etmek için kullanılan bit sayısı: Sayılar ve karakterler için kaç bit kullanıldığı.
- Giriş/Çıkış (I/O) Mekanizmaları: Bilgisayarın dış dünyayla nasıl iletişim kurduğu.
- Belleğe adresleme teknikleri: Verilere bellekte nasıl erişildiği. 
Özetle, bilgisayar mimarisi, programcının yazdığı programın nasıl davranacağını ve hangi kaynaklara erişebileceğini belirleyen üst düzey bir bakış açısıdır
#### 1.1.2 Bilgisayar Organizasyonu
Bilgisayar organizasyonu ise, mimari özellikleri gerçekleştiren operasyonel birimleri ve bunların birbirleri ile olan bağlantılarını ifade eder. Bu, programcıya şeffaf olan donanım detaylarını içerir.
Mimari tarafından belirlenen işlevselliği somutlaştırmak için kullanılan fiziksel bileşenleri ve nasıl yapılandırıldığını ele alır. 

Örnek nitelikleri: 
- **Kontrol sinyalleri:** İşlemci içindeki ve arasındaki veri akışını ve operasyonları yöneten sinyaller.
- **Bilgisayar ve çevre birimleri arasındaki arayüzler**: Giriş çıkış modüllerinin sisteme nasıl bağlandığı.
- **Kullanılan bellek teknolojisi**: RAM türü, önbellek yapısı gibi **donanımsal** detaylar
- **Dahili işlemci veri yolları**: İşlemci içindeki farklı birimler arasındaki iletişim yolları.
Örneğin, bir bilgisayarın mimarisi 32-bitlik bir veri yolu genişliği tanımlayabilir. Ancak organizasyonu, bu 32 veri yolunun fiziksel olarak nasıl uygulandığını, hangi yongalar arasındaki bağlantıları sağladığını ve veri transferlerini kontrol etmek için hangi sinyallerin kullanıldığını belirler. 

Başka bir örnek olarak, komut setinde bir "**toplama**" komutu bulunması **mimari** bir özelliktir. Bu toplama işleminin ALU (Aritmetik Mantık Birimi) içinde nasıl gerçekleştirildiği ve hangi kontrol sinyallerinin aktive edildiği ise organizasyonel bir detaydır.

Sonuç olarak, **bilgisayar organizasyonu**, tanımlanan mimari özelliklerin donanımsal olarak nasıl hayata geçirildiğinin ayrıntılı bir planını sunar. Hem bilgisayar mimarisi hem de organizasyonu, bir bilgisayar sisteminin işlevselliği ve performansı üzerinde kritik bir rol oynar.

#### 1.1.3 IBM System / 370 Mimarisi
1970 yılında IBM tarafından tanıtılan bir bilgisayar mimarisidir. Bu mimari, önemli bir yenilik olarak, birkaç **farklı modeli** içermekteydi. Bu sayede, başlangıçta daha uygun fiyatlı ve yavaş bir model satın alan bir kullanıcı, ihtiyaçları arttıkça daha pahalı ve hızlı bir modele geçiş yapabiliyor, ancak mevcut yazılımlarını değiştirmek zorunda kalmıyordu. 

IBM, zaman içinde teknoloji geliştikçe yeni ve geliştirilmiş modeller sunmuş olsa da, bu yeni modeller aynı temel mimariyi korumuştur. 
Şaşırtıcı bir şekilde, System/370 mimarisi, zaman içinde yapılan bazı geliştirmelerle birlikte, günümüzde hala IBM'in ana bilgisayar ürün serisinin temel mimarisi olarak varlığını sürdürmektedir.  Bu durum, bir mimarin yıllarca var olabileceği ve teknolojik değişikliklerle birlikte organizasyonunun değişebileceği önemli bir örnektir.

System/370, aynı zamanda "aile kavramı" olarak bilinen bir yaklaşıma da öncülük etmiştir. Bu kavram, kullanıcılara aynı mimariyi sunan, ancak farklı fiyat ve performans özelliklerine sahip bir dizi bilgisayar modelini içerir. Fiyat ve performans farklılıkları, aynı mimarinin farklı donanımsal uygulamalarından kaynaklanır. 

Özetle, IBM System/370 mimarisi, gerekli esnekliği sunan, yazılım yatırımını koruyan ve teknolojik gelişmelere ayak uydurabilen başarılı bir bilgisayar mimarisi örneğidir. Farklı modelleri, yükseltme kolaylığı ve uzun ömürlülüğü sayesinde, uzun yıllar boyunca bilişim dünyasında önemli bir yere sahip olmuştur.

### 1.2 Yapı ve işlev 

#### 1.2.1 Hiyerarşik Düzen
Karmaşık sistemler hiyerarşik bir yapıya sahiptir. Bu, sistemin, her biri kendi içinde de hiyerarşik bir yapıya sahip olabilen birbirleriyle ilişkili alt sistemlerden oluştuğu anlamına gelir.

Hiyerarşik yapı karmaşık sistemlerin anlaşılması ve tasarlanması sürecini büyük ölçüde kolaylaştırır.

**Tasarımcı açısından** düşünürsek sistemin yalnızca **belirli bir seviyesi** ile ilgilenme ihtiyacı duyar. Bu da karmaşık genel yapıda kaybolmadan ilgili seviyeye ve bileşenlere odaklanmasını sağlar. 

**Açıklama açısından** ise karmaşık bir sistemi tanımlarken, yukarıdan aşağıya (top-down) bir yaklaşım benimsemek genellikle en açık ve etkili yöntemdir. Bu yaklaşımda, öncelikle sistemin ana bileşenleri ve işlevleri tanımlanır, ardından her bir bileşen daha alt seviyedeki alt bileşenlere ayrıştırılarak yapı ve işlevleri detaylandırılır. Bu sayede, karmaşık bir sistem adım adım ve anlaşılır bir şekilde açıklanabilir.
#### 1.2.2 Yapı (Structure): 
Bir seviyedeki bileşenlerin birbirleriyle nasıl ilişkili olduğunu ifade eder. Bu, bileşenlerin düzenlenme biçimi, aralarındaki bağlantılar ve iletişim yolları gibi fiziksel veya mantıksal düzenlemeleri kapsar. 
Örneğin, bir bilgisayarın yapısı denildiğinde, CPU, ana bellek, giriş/çıkış (I/O) birimleri ve bu birimleri birbirine bağlayan sistem ara bağlantısı (genellikle bir veri yolu - bus) akla gelir.
- CPU'nun kendi içindeki yapı ise kontrol birimi, ALU ve kaydedicilerden oluşur.
	- Kaydedicilerin ALU ile olan bağlantıları da CPU'nun iç yapısının bir parçasıdır.

Bir bilgisayarın dört temel yapısal bileşeni vardır:

##### Merkezi İşlem Birimi (CPU): 
Bilgisayarın operasyonunu kontrol eder ve veri işleme işlevlerini yerine getirir.
- **İç yapısı** kontrol birimi, aritmetik ve mantık birimi (ALU), kaydediciler ve CPU iç bağlantısından oluşur
- **İşlevi,** programdaki talimatları sırayla alıp (fetch), çözüp (decode) ve çalıştırmaktır. (execute)
##### Ana Bellek (Main Memory):
Verileri saklar.
- **Yapısı**, adreslenebilir bellek hücrelerinden oluşur.
- **İşlevi**, CPU tarafından ihtiyaç duyulan talimatları ve verileri geçici olarak depolamaktır.
- **Bellek hiyerarşisi** kavramı da, daha hızlı ve küçük olan önbelleklerden (cache) daha yavaş ve büyük olan ana belleğe kadar farklı seviyelerdeki bellek yapılarını içerir.
##### Giriş/Çıkış (I/O):
Bilgisayar ile dış ortam arasındaki veri hareketini sağlar.
- Yapısı, çevre birimleriyle (klavye, ekran, disk vb.) ve sistem ara bağlantısıyla (veri yolu) etkileşim kuran I/O modüllerinden oluşur.
- İşlevi, dış dünyadan veri almak ve işlenmiş veriyi dış dünyaya göndermektir.
##### Sistem Ara Bağlantısı (System Interconnection):
CPU, ana bellek ve I/O birimleri arasındaki iletişimi sağlayan mekanizmadır. En yaygın örneklerinden biri sistem veri yoludur (system bus). 
- Veri yolu, veri, adres ve kontrol hatlarından oluşur ve bu bileşenler arasında bilgi alışverişini mümkün kılar.
- Daha gelişmiş sistemlerde ise noktadan noktaya (point-to-point) bağlantılar veya PCI Express (PCIe) gibi daha karmaşık ara bağlantı yapıları kullanılabilir.
- Çok işlemcili sistemlerde, işlemciler arasındaki iletişimi sağlamak için farklı bağlantı ağları (interconnection networks) kullanılabilir.

#### 1.2.3 İşlev (Function): 
Yapı içindeki bireysel bileşenlerin operasyonunu, yani nasıl çalıştığını ve sistemin genel amacına nasıl katkıda bulunduğunu ifade eder. Bir bileşenin işlevi, genel sistemin bir parçası olarak gerçekleştirdiği özel görevdir.
Örneğin; 
- CPU'nun temel işlevi programdaki talimatları yürütmektir.
- Ana belleğin işlevi veri depolamaktır.
- ALU'nun işlevi aritmetik ve mantıksal işlemleri gerçekleştirmektir.
- Kontrol biriminin işlevi ise CPU'nun ve dolayısıyla bilgisayarın operasyonunu kontrol etmektir.

##### Veri İşleme: 
İşlemci veriler üzerinde aritmetik veya mantıksal işlemler gerçekleştirebilir.

##### Veri Depolama: 
Bellek, verileri kısa veya uzun süreli olarak saklayabilir.
##### Veri Hareketi: 
G/Ç birimleri, bilgisayar ile çevresel aygıtlar arasında veri transferi sağlar.

##### Kontrol: 
Kontrol ünitesi, diğer tüm bileşenlerin çalışmasını yönetir ve koordine eder. Bir komut, yürütme sırasının değiştirilmesini belirtebilir.


#### 1.2.4 Çok Çekirdekli Bilgisayar Yapısı
##### Merkezi işlem birimi (CPU)
- Talimatları getiren ve yürüten bilgisayar bölümü
- Bir ALU, bir kontrol ünitesi ve kayıtlardan oluşur
- Tek bir işlem birimine sahip bir sistemde işlemci olarak adlandırılır
##### Çekirdek

Bir işlemci çipi üzerindeki bireysel bir işlem birimidir. Tek CPU'lu bir sistemde işlevsellik açısından bir CPU'ya eşdeğer olabilir. Bir çekirdeğin genel işlevsel elemanları şunlardır:
- Komut Mantığı: Komutları getirme ve her bir komutu, komutun operasyonunu ve herhangi bir operandın bellek konumunu belirlemek için çözme görevlerini içerir.
- Aritmetik ve Mantık Birimi (ALU): Bir komut tarafından belirtilen operasyonu gerçekleştirir.
- Yükle/Depola Mantığı: Verilerin önbellek aracılığıyla ana belleğe ve ana bellekten transferini yönetir.
Özel işlem birimlerine çekirdekler de denir
Simülatör, bir komut setini başka bir sete eşleyen bir araçtır.
##### İşlemci
- Bir veya daha fazla çekirdek içeren fiziksel bir silikon parçası
- Talimatları yorumlayan ve yürüten bilgisayar bileşenidir
- Birden fazla çekirdek içeriyorsa çok çekirdekli işlemci olarak adlandırılır

#### 1.2.5 Önbellek (Cache) 
- İşlemci ve ana bellek arasında yer alan çok katmanlı bir bellek sistemidir. 
- Ana bellekten daha küçük ve daha hızlıdır.
- Temel amacı, ana bellekteki verilere erişim süresini kısaltarak bellek erişimini hızlandırmaktır. Bu hızlanma, yakın gelecekte kullanılma olasılığı yüksek olan verilerin ana bellekten önbelleğe yerleştirilmesiyle sağlanır.
##### Çoklu Seviyeli Önbellek: 
Performansı daha da artırmak için çoklu seviyeli cache kullanılır. Genellikle üç seviye bulunur:

- **Seviye 1 (L1) cache:** Çekirdeğe en yakın olan ve en hızlı ancak en küçük cache seviyesidir. L1 cache genellikle komut (I-cache) ve veri (D-cache) olmak üzere ikiye ayrılır.
- **Seviye 2 (L2) cache:** L1'den daha yavaş ancak daha büyüktür ve genellikle her çekirdeğe özel olabilir veya çekirdekler arasında paylaşılabilir.
- Seviye 3 (L3) cache: L2'den daha yavaş ve daha büyük olan bu seviye genellikle birden fazla çekirdek tarafından paylaşılır. Bazı sistemlerde L4 gibi daha fazla seviye de bulunabilir.
Cache seviyeleri işlemciden uzaklaştıkça **boyutları artar** ancak **erişim hızları düşer**. 

İşlemci öncelikle en hızlı ve en yakın olan L1 cache'inde aradığı veriyi bulmaya çalışır. Veri burada bulunamazsa (cache miss), sırasıyla L2 ve L3 cache'lerinde aranır. Veri hiçbir cache seviyesinde bulunamazsa, ana belleğe erişilir. 

L1 --> L2 --> L3 --> ANA BELLEK

##### Önbelleğin Faydaları:
- **Bellek gecikmesini azaltır:** Sık kullanılan verilere daha hızlı erişim sağlayarak işlemcinin bekleme süresini azaltır.
-  **Sistem performansını artırır:** Daha hızlı veri erişimi, programların daha hızlı çalışmasını sağlar ve genel sistem performansını yükseltir.
- **Veri yolu trafiğini azaltır:** Cache hit durumunda ana belleğe erişim gerekmediğinden, sistem veri yolu üzerindeki yük azalır.
##### Tasarım Elemanları:

- Cache Adresleri (Cache Addresses): Sanal (logical) veya fiziksel adresler kullanılabilir.
- Cache Boyutu (Cache Size): Performans ve maliyet arasında bir denge söz konusudur. İşlemci çiplerinde cache için ayrılan alan zamanla artmıştır.
- Eşleme Fonksiyonu (Mapping Function): Ana bellek bloklarının cache hatlarına nasıl eşleneceğini belirler. Doğrudan eşleme (direct), tam ilişkisel (associative) ve küme ilişkisel (set-associative) gibi teknikler bulunur
- Yer Değiştirme Algoritması (Replacement Algorithm): Cache dolu olduğunda hangi bloğun çıkarılacağını belirler. En az kullanılan (LRU) gibi algoritmalar vardır.
- Yazma Politikası (Write Policy): Cache'teki bir veri güncellendiğinde ana belleğin ne zaman güncelleneceğini belirler. Yazma yoluyla (write-through) ve geri yazma (write-back) gibi politikalar mevcuttur.
- Hat Boyutu (Line Size): Bir cache bloğunun (veya hattının) kaç kelime veya bayttan oluştuğunu ifade eder
##### Çok Çekirdekli Sistemlerde Cache:
Çok çekirdekli işlemcilerde cache organizasyonu daha karmaşık hale gelir. Her çekirdeğin kendi özel L1 ve L2 cache'leri olabileceği gibi, bazı seviyeler (özellikle L3) tüm çekirdekler tarafından paylaşılabilir. Cache tutarlılığı (cache coherence), birden fazla çekirdek aynı bellek konumundaki veriyi cache'lediğinde, tüm cache'lerdeki verinin tutarlı kalmasını sağlama sorunudur.


### 1.3 Bilgisayarların Tarihi

#### 1.3.1 Birinci Nesil - Vakum Tüpleri  

Bilgisayar tarihinin Birinci Nesli, dijital mantık elemanları ve bellek için vakum tüplerinin kullanıldığı dönemi ifade eder. Bu dönemin önemli bir örneği, IAS bilgisayarıdır.
- IAS bilgisayarının temel tasarım yaklaşımı, genellikle matematikçi John von Neumann'a atfedilen **depolanmış program** kavramıydı.
- Bu fikrin ilk yayınlanması 1945 yılında yeni bir bilgisayar olan EDVAC (Elektronik Ayrık Değişkenli Bilgisayar) için **von Neumann** tarafından yapılan bir öneriyle gerçekleşti.
- IAS bilgisayarının tasarımı, Princeton İleri Araştırmalar Enstitüsü'nde 1946 yılında başladı ve 1952 yılında tamamlandı.
- **IAS bilgisayarı**, sonraki tüm **genel amaçlı bilgisayarların** prototipi oldu.

IAS bilgisayarının yapısı (Şekil 1.6) aşağıdaki temel bileşenleri içeriyordu:
- Merkezi İşlem Birimi (CPU): Bilgisayarın işlemlerini kontrol eden ve veri işleme fonksiyonlarını yerine getiren birimdir. IAS bilgisayarında bu birim, Aritmetik-lojik birimi (CA) ve Program kontrol birimini (CC) içeriyordu.
- Ana Bellek (Main Memory): Hem verileri hem de komutları depolayan alandır. IAS bilgisayarının belleği 40 bitlik 1000 depolama konumundan (kelime) oluşuyordu.
- Giriş/Çıkış (I/O) Ekipmanları: Kontrol birimi tarafından işletilen, bilgisayarın dış dünya ile iletişimini sağlayan aygıtlardır.


![[Pasted image 20250411004607.png]]

IAS bilgisayarında çeşitli kayıtçılar (registers) bulunuyordu. Bunlardan bazıları şunlardır:

- AC (Akümülatör Kayıtçısı)

- MQ (Çarpım-Bölüm Kayıtçısı)

- MBR (Bellek Tampon Kayıtçısı): Belleğe depolanacak veya bellekten alınacak kelimeyi içerir
- IBR (Komut Tampon Kayıtçısı): Bellekteki bir kelimeden geçici olarak sağ taraftaki komutu tutmak için kullanılırdı.
- Modern sistemlerde bunun yerine genellikle pipeline kullanılır. IAS bilgisayarının her kelimesinde iki komut (sol ve sağ) bulunuyordu.
- PC (Program Sayacı): Bir sonraki alınacak komut çiftinin adresini içerir.
- MAR (Bellek Adres Kayıtçısı): Bir okuma veya yazma işlemi için bellekteki adresi belirtir.
- IR (Komut Kayıtçısı): Şu anda yürütülen 8-bitlik işlem kodu (opcode) komutunu içerir.

IAS bilgisayarı ayrıca ikili (binary) veriler üzerinde işlem yapabilen bir aritmetik ve mantık birimine (ALU) sahipti. Kontrol birimi ise bellekteki komutları yorumlayıp yürütülmelerini sağlıyordu. Giriş/çıkış (I/O) ekipmanları da kontrol birimi tarafından yönetiliyordu.

![[Pasted image 20250411025133.png]]
 
Şekil 1.7, IAS bilgisayarının bellek biçimlerini göstermektedir. Bellekte hem veri hem de komutlar saklanıyordu. Sayılar, bir işaret biti ve 39 büyüklük biti ile temsil ediliyordu. Komut kelimesi ise 20 bitlik sol ve sağ komut olmak üzere ikiye ayrılıyordu. Her bir 20 bitlik komut, 8 bitlik bir işlem kodu (opcode) ve 12 bitlik bir adres içeriyordu. Bu 12 bitlik adres, 4096 (2^12) farklı bellek konumunu adresleyebiliyordu.


##### Depolanmış Program kavramı  
Depolanmış program kavramı, hem verilerin hem de komutların aynı ana bellekte saklanması fikrine dayanır. Bu sayede bilgisayar, programları art arda (sıralı bir şekilde) çalıştırabilir. Programın yürütülmesi genel olarak getir (fetch), çöz (decode) ve çalıştır (execute) döngüsü şeklinde gerçekleşir. 

#### 1.3.2 İkinci Nesil - Transistörler

- Daha **Küçük**
- Daha **Ucuz**
- Daha az ısı yayar.
- Silikondan yapılmış katı hal cihazıdır
- 1947'de Bell Labs'ta icat edildi.
- Tam transistörlü bilgisayarlar ticari olarak 1950'lerin sonuna kadar mevcut değildi.


| Generation | Approximate Dates | Technology                      | Typical Speed (operations per second) |
|------------|-------------------|---------------------------------|---------------------------------------|
| 1          | 1946–1957         | Vacuum tube                     | 40,000                                |
| 2          | 1957–1964         | Transistor                      | 200,000                               |
| 3          | 1965–1971         | Small and medium scale integration | 1,000,000                             |
| 4          | 1972–1977         | Large scale integration         | 10,000,000                            |
| 5          | 1978–1991         | Very large scale integration    | 100,000,000                           |
| 6          | 1991-             | Ultra large scale integration   | >1,000,000,000                        |

##### İkinci Nesil Bilgisayarlar


**Tanıtılan Yenilikler:**

* Daha karmaşık aritmetik ve mantık birimleri (ALU) ve kontrol birimleri.
* Yüksek seviyeli programlama dillerinin kullanımı.
* Aşağıdaki yetenekleri sağlayan sistem yazılımlarının sunulması:
    * Programları yükleme
    * Verileri çevresel birimlere taşıma
    * Kütüphanelerin yaygın hesaplamaları yapması


![[Pasted image 20250411030523.png]]


#### 1.3.3 Üçüncü Nesil - Entegre Devre
Bilgisayar tarihinin Üçüncü Nesli, entegre devrelerin icadıyla tanımlanır. 1958 yılında icat edilen entegre devreler, elektronik alanında bir devrim başlatmıştır. 

Bu nesilden önce, elektronik ekipmanlar büyük ölçüde ayrık bileşenlerden oluşuyordu. Tek başına, kendi kendine yeten bir transistör olan bu ayrık bileşenler ayrı ayrı üretiliyor, kendi kutularında paketleniyor ve masonit benzeri devre kartlarına lehimleniyor veya kablolanıyordu. Bu üretim süreci hem pahalı hem de zahmetliydi. İkinci nesil bilgisayarlarda kullanılan transistör sayısı yüz binlere ulaşınca, daha güçlü makinelerin üretimi giderek zorlaşmaya başlamıştı.

Entegre devre, bu sorunlara bir çözüm getirerek mikroelektronik çağını başlatmıştır. Temel bilgisayar elemanları olan mantık kapıları (gates) ve bellek hücreleri (memory cells), transistörler ve kapasitörler gibi basit dijital elektronik bileşenlerden inşa edilir. Entegre devreler, transistörler, dirençler ve iletkenler gibi bileşenlerin silikon gibi bir yarı iletkenden üretilebilmesi gerçeğini kullanır. Ayrı ayrı silikon parçalarından yapılan ayrık bileşenleri aynı devreye monte etmek yerine, bütün bir devre minik bir silikon parçası üzerine fabrikasyonla yerleştirilir. Tek bir silikon gofret **(wafer)** üzerinde aynı anda çok sayıda transistör üretilebilir. Daha da önemlisi, bu transistörler işlemci metalizasyonu ile bağlanarak devreleri oluşturabilirler. 

Şekil 1.10'da görüldüğü gibi, bir bilgisayar temelde veri depolama, işleme, taşıma ve kontrol fonksiyonlarını yerine getiren kapılar ve bellek hücreleri olmak üzere iki temel bileşen türüne ihtiyaç duyar.

![[Pasted image 20250411031534.png]]

- Veri depolama, bellek hücreleri tarafından sağlanır.
- Veri işleme, kapılar tarafından sağlanır.
- Veri hareketi, bileşenler arasındaki yollar aracılığıyla, bellekten belleğe ve bellekten kapılara doğru gerçekleşir.
- Kontrol, bileşenler arasındaki yollar aracılığıyla kontrol sinyalleri taşınarak sağlanır.


Şekil 1.11, entegre devrelerdeki temel kavramları göstermektedir. İnce bir silikon gofret, her biri birkaç milimetre kare olan küçük alanların bir matrisine bölünür. Her alanda aynı devre deseni oluşturulur ve gofret çipler halinde kesilir. Her bir çip, birçok kapı ve/veya bellek hücresi ile birlikte bir dizi giriş ve çıkış bağlantı noktası içerir. Bu çip daha sonra, onu koruyan ve çipin ötesindeki cihazlara bağlanmak için pinler sağlayan bir pakete yerleştirilir.

![[Pasted image 20250411031629.png]]

Entegre devrelerin ayrık bileşenlere göre birçok avantajı vardır:

- Maliyet düşüklüğü: Silikon üzerindeki bileşenlerin toplu üretimi maliyeti düşürür.
- Küçük boyut: Çok sayıda bileşen küçük bir alana sığdırılabilir.
- Yüksek hız: Mantık ve bellek elemanları birbirine daha yakın yerleştirildiğinden, elektrik yolu kısalır ve çalışma hızı artar.
- Daha az güç tüketimi.
- Daha yüksek güvenilirlik: Entegre devre üzerindeki bağlantılar, lehim bağlantılarından daha güvenilirdir ve çip başına daha fazla devre olduğundan, çipler arası bağlantı sayısı azalır.


Üçüncü neslin en önemli iki üyesi IBM System/360 ve DEC PDP-8 olmuştur.

DEC PDP-8, nispeten düşük maliyeti ve küçük boyutu sayesinde diğer üreticilerin PDP-8'i kendi sistemlerine entegre ederek yeniden satmalarını sağlamıştır. Bu üreticilere orijinal ekipman üreticileri (OEM) denmiş ve OEM pazarı bilgisayar pazarının önemli bir bölümü haline gelmiştir. IBM'in 700/7000 ve 360 sistemlerinde kullanılan merkezi anahtarlamalı mimarinin (Şekil 1.9) aksine, PDP-8'in sonraki modelleri, mikrobilgisayarlar için neredeyse evrensel hale gelen bir yapı kullanmıştır: bus yapısı (Şekil 1.13). PDP-8 bus'ı, Omnibus, kontrol, adres ve veri sinyallerini taşımak için kullanılan 96 ayrı sinyal yolundan oluşuyordu.




Şekil 1.12, entegre devrelerdeki transistör sayısındaki büyümeyi göstermektedir. Bu büyüme, daha önceki konuşmamızda da bahsettiğimiz gibi, Intel'in kurucu ortağı Gordon Moore tarafından 1965'te öne sürülen Moore Yasası ile yakından ilişkilidir. Moore Yasası, bir yonga üzerine yerleştirilebilecek transistör sayısının yaklaşık olarak her iki yılda bir ikiye katlanacağını öngörüyordu. 

![[Pasted image 20250411032737.png]]

#### 1.3.4  Sonraki nesiller - Yarıiletken Bellek Mikroişlemcileri

Bilgisayar tarihinin üçüncü neslinden sonraki dönemler, entegre devre teknolojisindeki ilerlemelerle tanımlanmıştır.

| Generation | Approximate Dates | Technology                      | Typical Speed (operations per second) |
|------------|-------------------|---------------------------------|---------------------------------------|
| 1          | 1946–1957         | Vacuum tube                     | 40,000                                |
| 2          | 1957–1964         | Transistor                      | 200,000                               |
| 3          | 1965–1971         | Small and medium scale integration | 1,000,000                             |
| 4          | 1972–1977         | Large scale integration         | 10,000,000                            |
| 5          | 1978–1991         | Very large scale integration    | 100,000,000                           |
| 6          | 1991-             | Ultra large scale integration   | >1,000,000,000                        |
Sonraki nesilleri entegre devrelerdeki bileşen sayısına göre sınıflandırmaktadır.

- LSI (Large Scale Integration): Tek bir entegre devre çipinde 1.000'den fazla bileşenin yerleştirilebildiği dönem. 
	- Bu dönem kabaca 1972-1977 yıllarını kapsar.
- VLSI (Very Large Scale Integration): Çip başına 10.000'den fazla bileşenin sığdırılabildiği dönem.
	-  Bu dönem yaklaşık olarak 1978-1991 yıllarını kapsar.
- ULSI (Ultra Large Scale Integration): Günümüzde kullanılan ve bir milyardan fazla bileşeni tek bir çip üzerinde barındırabilen teknolojidir.
	-  Bu dönem 1991 yılından sonra başlamıştır.
Bu dönemlerdeki en önemli gelişmelerden ikisi yarı iletken bellekler ve mikroişlemciler olmuştur.

##### 1.3.4.1 Yarı İletken Bellekler:
- 1970 yılında Fairchild, nispeten büyük kapasiteli ilk yarı iletken belleği üretmiştir. Bu çip, tek bir manyetik çekirdek boyutlarındaydı ve 256 bit veri saklayabiliyordu. Ayrıca non-destrüktif (okuma sırasında veri silinmiyordu) ve manyetik çekirdekten çok daha hızlıydı.
- 1974 yılında yarı iletken belleğin bit başına maliyeti, manyetik çekirdek belleğin maliyetinin altına düşmüştür. Bu olay, yarı iletken belleğin ana bellek teknolojisi olarak yaygınlaşmasının önünü açmıştır.
- 1970'ten bu yana yarı iletken bellek teknolojisi 13 nesil geçirmiştir. Her yeni nesil, bir önceki neslin dört katı depolama yoğunluğu sunarken, bit başına maliyet düşmüş ve erişim süresi kısalmıştır. Örneğin, 1k, 4k, 16k, 64k, 256k, 1M, 4M, 16M, 64M, 256M, 1G, 4G ve günümüzde 8 Gb'lık çipler üretilmiştir. 
- Bellek teknolojisindeki bu hızlı gelişmeler, bilgisayarların yapısını önemli ölçüde değiştirmiş ve daha küçük, daha hızlı ve daha büyük bellek kapasitelerine sahip makinelerin ortaya çıkmasını sağlamıştır
##### 1.3.4.2 Mikroişlemciler:
- İşlemci çiplerindeki eleman yoğunluğu sürekli olarak artmıştır. Bu sayede tek bir bilgisayar işlemcisini oluşturmak için gereken çip sayısı azalmıştır.
- 1971 yılında Intel, bir CPU'nun tüm bileşenlerini **tek bir çip** üzerinde barındıran ilk çip olan **4004**'ü geliştirmiştir. Bu, mikroişlemcinin doğuşu olarak kabul edilir. 
	- 4004, 4-bitlik sayıları toplayabiliyor ve yalnızca tekrarlı toplama yoluyla çarpma işlemi yapabiliyordu.
- 1972 yılında Intel, ilk 8-bit mikroişlemci olan 8008'i geliştirmiştir.
- 1974 yılında Intel, ilk genel amaçlı mikroişlemci olan 8080'i piyasaya sürmüştür. 8080, 8-bitlik bir mikroişlemci olmasına rağmen, 4004 ve 8008'e göre daha hızlıydı, daha zengin bir komut kümesine sahipti ve daha geniş bir adresleme yeteneği sunuyordu.
	- 8080, ilk kişisel bilgisayar olan Altair'de kullanılmıştır.
- Aynı dönemde 16-bit mikroişlemciler de geliştirilmeye başlanmış, 1970'lerin sonunda ise güçlü ve genel amaçlı 16-bit mikroişlemciler ortaya çıkmıştır. Bunlardan biri 8086 idi. 8088, 8086'nın bir türeviydi ve IBM'in ilk kişisel bilgisayarında kullanılarak Intel'in başarısını sağlamlaştırmıştır. 8086, x86 mimarisinin ilk görünümüdür.
- Daha sonra 32-bit mikroişlemciler geliştirilmiştir. Intel'in ilk 32-bit işlemcisi olan 80386, 1985 yılında piyasaya sürülmüştür ve çoklu görev (multitasking) desteği sunan ilk Intel işlemcisidir.
- Intel'in mikroişlemci evrimi, Moore Yasası ile yakından ilişkilidir. Gordon Moore, 1965 yılında tek bir çip üzerine yerleştirilebilecek transistör sayısının her yıl ikiye katlandığını gözlemlemiş ve bu hızın devam edeceğini öngörmüştür.
- Daha sonra bu hız her 18 ayda bir ikiye katlanma şeklinde revize edilmiş ve bu oran büyük ölçüde korunmuştur.
- Moore Yasası'nın sonuçları arasında bilgisayar mantık ve bellek devrelerinin maliyetinin düşmesi, çalışma hızının artması, bilgisayarların küçülmesi, güç tüketiminin azalması ve çip arası bağlantı sayısının azalması yer alır.
- Bu gelişmeler, bilgisayar teknolojisinin sonraki nesillerinde çok daha karmaşık ve güçlü sistemlerin ortaya çıkmasına olanak tanımıştır.

##### 1.3.4.3 Intel Mikroişlemcilerin Evrimi

###### (a) 1970s Processors

|                     | 4004     | 8008     | 8080     | 8086                 | 8088           |
|---------------------|----------|----------|----------|----------------------|----------------|
| Introduced          | 1971     | 1972     | 1974     | 1978                 | 1979           |
| Clock speeds        | 108 kHz  | 108 kHz  | 2 MHz    | 5 MHz, 8 MHz, 10 MHz | 5 MHz, 8 MHz   |
| Bus width           | 4 bits   | 8 bits   | 8 bits   | 16 bits              | 8 bits         |
| Number of transistors| 2,300    | 3,500    | 6,000    | 29,000               | 29,000         |
| Feature size (µm)   | 10       | 8        | 6        | 3                    | 6              |
| Addressable memory  | 640 Bytes| 16 KB    | 64 KB    | 1 MB                 | 1 MB           |


###### (b) 1980s Processors

|                     | 80286          | 386TM DX         | 386TM SX         | 486TM DX CPU     |
|---------------------|----------------|------------------|------------------|------------------|
| Introduced          | 1982           | 1985             | 1988             | 1989             |
| Clock speeds        | 6 MHz - 12.5 MHz| 16 MHz - 33 MHz  | 16 MHz - 33 MHz  | 25 MHz - 50 MHz  |
| Bus width           | 16 bits        | 32 bits          | 16 bits          | 32 bits          |
| Number of transistors| 134,000        | 275,000          | 275,000          | 1.2 million      |
| Feature size (µm)   | 1.5            | 1                | 1                | 0.8 - 1          |
| Addressable memory  | 16 MB          | 4 GB             | 16 MB            | 4 GB             |
| Virtual memory      | 1 GB           | 64 TB            | 64 TB            | 64 TB            |
| Cache               | —              | —                | —                | 8 kB             |

###### (c) 1990s Processors


|                       | 486TM SX        | Pentium          | Pentium Pro           | Pentium II        |
| --------------------- | --------------- | ---------------- | --------------------- | ----------------- |
| Introduced            | 1991            | 1993             | 1995                  | 1997              |
| Clock speeds          | 16 MHz - 33 MHz | 60 MHz - 166 MHz | 150 MHz - 200 MHz     | 200 MHz - 300 MHz |
| Bus width             | 32 bits         | 32 bits          | 64 bits               | 64 bits           |
| Number of transistors | 1.185 million   | 3.1 million      | 5.5 million           | 7.5 million       |
| Feature size (µm)     | 1               | 0.8              | 0.6                   | 0.35              |
| Addressable memory    | 4 GB            | 4 GB             | 64 GB                 | 64 GB             |
| Virtual memory        | 64 TB           | 64 TB            | 64 TB                 | 64 TB             |
| Cache                 | 8 kB            | 8 kB             | 512 kB L1 and 1 MB L2 | 512 kB L2         |

###### (d) Recent Processors

|                       | Pentium III   | Pentium 4     | Core 2 Duo     | Core i7 EE 4960X     |
| --------------------- | ------------- | ------------- | -------------- | -------------------- |
| Introduced            | 1999          | 2000          | 2006           | 2013                 |
| Clock speeds          | 450 - 660 MHz | 1.3 - 1.8 GHz | 1.06 - 1.2 GHz | 4 GHz                |
| Bus width             | 64 bits       | 64 bits       | 64 bits        | 64 bits              |
| Number of transistors | 9.5 million   | 42 million    | 167 million    | 1.86 billion         |
| Feature size (nm)     | 250           | 180           | 65             | 22                   |
| Addressable memory    | 64 GB         | 64 GB         | 64 GB          | 64 GB                |
| Virtual memory        | 64 TB         | 64 TB         | 64 TB          | 64 TB                |
| Cache                 | 512 kB L2     | 256 kB L2     | 2 MB L2        | 1.5 MB L2 / 15 MB L3 |
| Number of cores       | 1             | 1             | 2              | 6                    |
|                       |               |               |                |                      |

###### Intel x86 Mimarisinin Evrimi

Intel x86 ve ARM mimarileri, günümüzdeki iki temel işlemci ailesini temsil etmektedir. Mevcut x86 işlemcileri, karmaşık komut seti bilgisayarları (CISC) üzerine on yıllarca süren bir tasarım çalışmasının sonucudur. Buna karşılık, indirgenmiş komut seti bilgisayarı (RISC), işlemci tasarımında alternatif bir yaklaşımı temsil eder. ARM mimarisi, çok çeşitli gömülü sistemlerde kullanılmakta olup, piyasadaki en güçlü ve en iyi tasarlanmış RISC tabanlı sistemlerden biridir.

.
.

| İşlemci     | Öne Çıkan Özellikler                                                                                                                                                                                                                                                                                       |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 4004        | 1971'de , bir CPU'nun tüm bileşenlerini tek bir çip üzerinde barındıran ilk çipti ve mikroişlemcinin doğuşunu işaret etti. Ancak, sadece 4-bitlik sayılarla işlem yapabiliyor ve çarpma işlemini tekrarlı toplama ile gerçekleştirebiliyordu.                                                              |
| 8008        | 1972'de, ilk 8-bit mikroişlemci olarak ortaya çıktı.                                                                                                                                                                                                                                                       |
| 8080        | - Dünyanın ilk genel amaçlı mikroişlemcisi  <br> - 8-bit makine, belleğe 8-bit veri yolu  <br> - İlk kişisel bilgisayarda (Altair) kullanıldı<br> - 8-bitlik olmasına rağmen, daha hızlıydı, daha zengin bir komut setine ve daha geniş bir adresleme yeteneğine sahipti.                                  |
| 8086        | - 1978'de Intel 8086, daha güçlü bir 16-bit makineydi<br> - Talimatları yürütülmeden önce önbelleğe alan bir komut kuyruğuna sahiptir.  <br> - x86 mimarisinin ilk ortaya çıkışı   <br> - 8088 bu işlemcinin bir varyantıydı ve IBM'in ilk kişisel bilgisayarında kullanıldı (Intel'in başarısını sağladı) |
| 80286       | - 8086’nın genişletilmiş versiyonu, sadece 1 MB yerine 16 MB belleğe adresleme yapılmasını sağladı                                                                                                                                                                                                         |
| 80386       | - Intel'in ilk 32-bit işlemcisi  <br> - Çoklu görev desteği sunan ilk Intel işlemcisi                                                                                                                                                                                                                      |
| 80486       | - Daha gelişmiş ve güçlü önbellek teknolojisinin ve gelişmiş komut ardışıklığının (instruction pipelining) kullanımı  <br> - Dahili matematik işlem birimi (coprocessor) içeriyordu                                                                                                                        |
| Pentium     | - Birden fazla komutun aynı anda yürütülmesine olanak tanıyan superscalar (üstdizisel) tekniklerin kullanımını tanıttı                                                                                                                                                                                     |
| Pentium Pro | - Superscalar yapıya geçiş devam etti; kayıt yeniden adlandırma, dallanma tahmini, veri akışı analizi ve varsayımsal yürütme gibi teknikler yoğun şekilde kullanıldı                                                                                                                                       |
| Pentium II  | - Video, ses ve grafik verilerini verimli bir şekilde işlemek için özel olarak tasarlanmış Intel MMX teknolojisini entegre etti                                                                                                                                                                            |
| Pentium III | - Ek kayan nokta komutları içerir  <br> - SIMD Akış Uzantıları (SSE) içerir                                                                                                                                                                                                                                |
| Pentium 4   | - Multimedya için ek kayan nokta komutları ve diğer geliştirmeler içerir                                                                                                                                                                                                                                   |
| Core        | - İlk Intel x86 mikro çekirdeği                                                                                                                                                                                                                                                                            |
| Core 2      | - Core mimarisini 64 bit'e genişletir  <br> - Core 2 Quad tek bir çip üzerinde dört çekirdek sağlar  <br> - Daha yeni Core sürümleri çip başına 10'a kadar çekirdek içerebilir  <br> - Mimaride önemli bir ekleme: Gelişmiş Vektör Uzantıları (AVX) komut seti                                             |

###### CISC ve RISC Yaklaşımları

Kaynaklar, **x86** mimarisinin bir **CISC (Complex Instruction Set Computer - Karmaşık Komut Seti Bilgisayarı)** mimarisi olduğunu belirtirken, **ARM** mimarisinin ise **RISC (Reduced Instruction Set Computer - İndirgenmiş Komut Seti Bilgisayarı)** tasarım prensiplerinden evrimleştiğini vurgulamaktadır.

- **CISC mimarileri**, genellikle çok sayıda karmaşık komuta sahiptir ve derleyicileri basitleştirmeyi, performansı artırmayı hedefler.  
  Ancak bu karmaşıklık, işlemci tasarımını zorlaştırabilir.  
  **x86'nın** karmaşık komut seti; geriye dönük uyumluluk ihtiyacı ve derleyici geliştiricilerine mümkün olan en fazla desteği sağlama isteğinden kaynaklanmaktadır.

- **RISC mimarileri** ise daha az sayıda, basit komutlara odaklanır ve komut işlem hattını (**pipeline**) optimize etmeyi amaçlar.  
  **ARM mimarisi**, enerji verimliliği ve küçük çip boyutu ile bilinir; bu da onu **gömülü sistemlerde** yaygın kılar.

RISC ve CISC Yakınsaması

Son yıllarda, **RISC** ve **CISC** yaklaşımları arasında bir **yakınsama** olduğu görülmektedir:

- **RISC tasarımları**, bazı **CISC** özelliklerinden faydalanabilir.
- **CISC tasarımları** ise, performansı artırmak için **RISC prensiplerini** benimseyebilir.  
  Örneğin, modern **x86 işlemcileri**, **superscalar** yapılar ve **işlem hattı** gibi RISC temelli teknikleri kullanmaktadır.

 Sonuç olarak, 

- **Intel x86 mimarisi**, yıllar içinde sürekli olarak gelişmiş ve karmaşıklaşmıştır.
  - Geriye dönük uyumluluk ve geniş uygulama desteği ihtiyacı, **CISC** yapısının korunmasına neden olmuştur.
- Buna karşılık, **ARM mimarisi**, **RISC** prensipleriyle yola çıkarak özellikle gömülü sistemlerde büyük bir başarıya ulaşmıştır.

Her iki mimari de:
- Performans
- Enerji verimliliği

gibi faktörleri dengeleyerek evrimleşmeye devam etmektedir.


